{"question_type":"code_audit","instructions":"Identify the vulnerability in the smart contract and provide fixed code","contract_code":"contract VulnerableBank {\n    mapping(address => uint) public balances;\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n    function withdraw(uint _amount) external {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        (bool success, ) = msg.sender.call{valueÔºö _amount}(\"\"); \n        require(success, \"Transfer failed\");\n        balances[msg.sender] -= _amount; \n    }\n}","vulnerability_type":"reentrancy","scoring_criteria":[{"criterion":"identifies_vulnerability_type","points":2,"keywords":["reentrancy","reentrant","ÈáçÂÖ•"]},{"criterion":"follows_checks_effects_interactions","points":3,"check_function":"check_state_update_before_external_call"},{"criterion":"implements_reentrancy_guard","points":2,"check_function":"check_reentrancy_guard"},{"criterion":"code_compiles","points":1,"check_function":"validate_solidity_code"}],"automated_tests":["test_deposit_withdraw_workflow","test_reentrancy_attack_prevention"],"reference_solution":"contract SecureBank {\n    mapping(address => uint) public balances;\n    bool private locked;\n    modifier noReentrant() {\n        require(!locked, \"Reentrant call detected\");\n        locked = true;\n        _;\n        locked = false;\n    }\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n    function withdraw(uint _amount) external noReentrant {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        balances[msg.sender] -= _amount;\n        (bool success, ) = msg.sender.call{valueÔºö _amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}"}
{"question_type":"code_audit","instructions":"Identify the vulnerability in the smart contract and provide fixed code","contracts":[{"language":"Solidity","contract_code":"// Solidity 0.8.x\ncontract VulnerableBank {\n    mapping(address => uint) public balances;\n    \n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n    \n    function withdraw() external {\n        uint amount = balances[msg.sender];\n        require(address(this).balance >= amount, 'Insufficient funds');\n        (bool success, ) = msg.sender.call{valueÔºö amount}('');\n        require(success);\n        balances[msg.sender] = 0;\n    }\n}","vulnerability_type":"reentrancy","scoring_criteria":[{"criterion":"identifies_vulnerability_type","points":2,"keywords":["reentrancy","reentrant"]},{"criterion":"follows_checks_effects_interactions","points":3,"check_function":"check_state_update_before_call"},{"criterion":"implements_reentrancy_guard","points":2,"check_function":"check_reentrancy_lock"},{"criterion":"code_compiles","points":1,"check_function":"validate_solidity_code"}],"automated_tests":["test_reentrancy_attack_prevention"],"reference_solution":"// Solidity 0.8.x\ncontract SecureBank {\n    mapping(address => uint) public balances;\n    bool private locked;\n    \n    modifier noReentrant() {\n        require(!locked, 'Reentrancy detected');\n        locked = true;\n        _;\n        locked = false;\n    }\n    \n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n    \n    function withdraw() external noReentrant {\n        uint amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        (bool success, ) = msg.sender.call{valueÔºö amount}('');\n        require(success);\n    }\n}"},{"language":"Move","contract_code":"// Move\nmodule MyToken {\n    struct Coin has key {}\n    \n    public entry transfer(senderÔºö &signerÔºå receiverÔºö addressÔºå amountÔºö u64) {\n        let coinÔºö Coin<amount> = move_from<@Coin>(sender);\n        move_to<@Coin>(receiverÔºå Coin { valueÔºö amount });\n    }\n}","vulnerability_type":"resource_leak","scoring_criteria":[{"criterion":"identifies_vulnerability_type","points":2,"keywords":["resource leak","ËµÑÊ∫êÊ≥ÑÊºè"]},{"criterion":"correct_resource_management","points":3,"check_function":"check_resource_transfer"},{"criterion":"code_compiles","points":1,"check_function":"validate_move_code"}],"automated_tests":["test_resource_integrity"],"reference_solution":"// Move\nmodule MyToken {\n    struct Coin has key { valueÔºö u64 }\n    \n    public entry transfer(senderÔºö &signerÔºå receiverÔºö addressÔºå amountÔºö u64) {\n        let coinÔºö Coin<amount> = move_from<@Coin>(sender);\n        move_to<@Coin>(receiverÔºå Coin { valueÔºö amount });\n        // Correctly destroy the original coin\n        destroy<@Coin>(coin);\n    }\n}"},{"language":"Go","contract_code":"// Go\npackage main\nimport \"fmt\"\n\nvar balance = make(map[string]int)\n\nfunc Deposit(addr stringÔºå amount int) {\n    balance[addr] += amount\n}\n\nfunc Withdraw(addr string) {\n    amount := balance[addr]\n    fmt.Printf(\"Withdrawing %d\\n\"Ôºå amount)\n    balance[addr] = 0\n}\n\nfunc main() {\n    go Deposit(\"alice\", 100)\n    Withdraw(\"alice\")\n    Deposit(\"alice\", 50)\n    fmt.Println(balance[\"alice\"]) // Expected 50 but may get 0\n}","vulnerability_type":"race_condition","scoring_criteria":[{"criterion":"identifies_vulnerability_type","points":2,"keywords":["race condition","Á´ûÊÄÅÊù°‰ª∂"]},{"criterion":"implements_mutex","points":3,"check_function":"check_mutex_usage"},{"criterion":"code_compiles","points":1,"check_function":"validate_go_code"}],"automated_tests":["test_concurrency_safety"],"reference_solution":"// Go\npackage main\nimport (\"fmt\"; \"sync\")\n\nvar balance = make(map[string]int)\nvar mu sync.Mutex\n\nfunc Deposit(addr stringÔºå amount int) {\n    mu.Lock()\n    defer mu.Unlock()\n    balance[addr] += amount\n}\n\nfunc Withdraw(addr string) {\n    mu.Lock()\n    defer mu.Unlock()\n    amount := balance[addr]\n    fmt.Printf(\"Withdrawing %d\\n\"Ôºå amount)\n    balance[addr] = 0\n}\n"},{"language":"Solidity","contract_code":"// Solidity 0.8.x\ncontract VulnerableToken {\n    mapping(address => uint) public balances;\n    \n    function transfer(address _toÔºå uint _value) external {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n    }\n}","vulnerability_type":"integer_overflow","scoring_criteria":[{"criterion":"identifies_vulnerability_type","points":2,"keywords":["integer overflow"]},{"criterion":"uses_safe_math","points":3,"check_function":"check_safe_math"},{"criterion":"code_compiles","points":1,"check_function":"validate_solidity_code"}],"automated_tests":["test_overflow_prevention"],"reference_solution":"// Solidity 0.8.x\ncontract SafeToken {\n    using SafeMath for uint;\n    mapping(address => uint) public balances;\n    \n    function transfer(address _toÔºå uint _value) external {\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n    }\n}\n// Requires SafeMath library implementation"},{"language":"Rust","contract_code":"// Rust\nstruct Bank {\n    balancesÔºö std::collections::HashMap<StringÔºå u32>,\n}\n\nimpl Bank {\n    pub fn new() -> Bank {\n        Bank { balancesÔºö HashMap::new() }\n    }\n    \n    pub fn deposit(&mut selfÔºå addrÔºö &strÔºå amountÔºö u32) {\n        let current = self.balances.get(addr).unwrap_or(&0);\n        self.balances.insert(addr.to_string()Ôºå current + amount);\n    }\n    \n    pub fn withdraw(&mut selfÔºå addrÔºö &strÔºå amountÔºö u32) {\n        let current = self.balances.get_mut(addr).unwrap();\n        *current -= amount;\n    }\n}","vulnerability_type":"unwrap_panic","scoring_criteria":[{"criterion":"identifies_vulnerability_type","points":2,"keywords":["unwrap","panic"]},{"criterion":"handles_option","points":3,"check_function":"check_option_handling"},{"criterion":"code_compiles","points":1,"check_function":"validate_rust_code"}],"automated_tests":["test_safe_option_handling"],"reference_solution":"// Rust\nuse std::collections::HashMap;\n\nstruct Bank {\n    balancesÔºö HashMap<StringÔºå u32>,\n}\n\nimpl Bank {\n    pub fn new() -> Bank {\n        Bank { balancesÔºö HashMap::new() }\n    }\n    \n    pub fn deposit(&mut selfÔºå addrÔºö &strÔºå amountÔºö u32) {\n        *self.balances.entry(addr.to_string()).or_insert(0) += amount;\n    }\n    \n    pub fn withdraw(&mut selfÔºå addrÔºö &strÔºå amountÔºö u32) -> Result<()Ôºå String> {\n        let entry = self.balances.get_mut(addr);\n        match entry {\n            Some(v) if *v >= amount => {\n                *v -= amount;\n                Ok(())\n            },\n            _ => Err(\"Insufficient funds\".to_string()),\n        }\n    }\n}"}]}
{"question_type":"code_audit","instructions":"Identify the vulnerability in the smart contract and provide fixed code","contract_code":"contract VulnerableBank {\n    mapping(address => uint) public balances;\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n    function withdraw(uint _amount) external {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        (bool success, ) = msg.sender.call{valueÔºö _amount}(\"\"); \n        require(success, \"Transfer failed\");\n        balances[msg.sender] -= _amount; \n    }\n}","vulnerability_type":"reentrancy","scoring_criteria":[{"criterion":"identifies_vulnerability_type","points":2,"keywords":["reentrancy","reentrant","ÈáçÂÖ•"]},{"criterion":"follows_checks_effects_interactions","points":3,"check_function":"check_state_update_before_external_call"},{"criterion":"implements_reentrancy_guard","points":2,"check_function":"check_reentrancy_guard"},{"criterion":"code_compiles","points":1,"check_function":"validate_solidity_code"}],"automated_tests":["test_deposit_withdraw_workflow","test_reentrancy_attack_prevention"],"reference_solution":"contract SecureBank {\n    mapping(address => uint) public balances;\n    bool private locked;\n    modifier noReentrant() {\n        require(!locked, \"Reentrant call detected\");\n        locked = true;\n        _;\n        locked = false;\n    }\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n    function withdraw(uint _amount) external noReentrant {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        balances[msg.sender] -= _amount;\n        (bool success, ) = msg.sender.call{valueÔºö _amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}"}
{"question_type":"code_audit","instructions":"Identify the efficiency issue in the smart contract and provide fixed code","contract_code":"contract GasInefficientContract {\n    uint[] public values;\n    function addValue(uint _value) public {\n        values.push(_value);\n    }\n    function getTotalValues() public view returns(uint total) {\n        for (uint i = 0; i < values.length; i++) {\n            total += values[i];\n        }\n    }\n}","vulnerability_type":"gas optimization","scoring_criteria":[{"criterion":"identifies_gas_inefficiency","points":2,"keywords":["gas","optimization","inefficiency"]},{"criterion":"provides_gas_optimized_solution","points":3,"check_function":"check_gas_optimization"},{"criterion":"code_compiles","points":1,"check_function":"validate_solidity_code"}],"automated_tests":["test_add_value","test_get_total_values"],"reference_solution":"contract GasOptimizedContract {\n    uint total;\n    function addValue(uint _value) public {\n        total += _value;\n    }\n    function getTotalValues() public view returns(uint) {\n        return total;\n    }\n}"}
{"question_type":"code_audit","instructions":"Identify the issue in the Move contract and provide fixed code","contract_code":"module VulnerableModule {\n    public fun create_account(accountÔºö address)Ôºö address {\n        let account_balance = 0;\n        return account_balance;\n    }\n}","vulnerability_type":"resource initialization","scoring_criteria":[{"criterion":"identifies_resource_initialization","points":2,"keywords":["resource","initialization"]},{"criterion":"provides_valid_resource_type","points":3,"check_function":"check_resource_type"},{"criterion":"code_compiles","points":1,"check_function":"validate_move_code"}],"automated_tests":["test_create_account"],"reference_solution":"module FixedModule {\n    public fun create_account(accountÔºö address)Ôºö &mut account_balance {\n        let account_balance = 0;\n        return account_balance;\n    }\n}"}
{"question_type":"code_audit","instructions":"Identify the concurrency issue in the Go code and provide fixed code","contract_code":"package main\nimport \"sync\"\ntype BankAccount struct {\n    balance int\n    mu sync.Mutex\n}\nfunc (a *BankAccount) Deposit(amount int) {\n    a.balance += amount\n}\nfunc (a *BankAccount) Withdraw(amount int) {\n    if a.balance >= amount {\n        a.balance -= amount\n    }\n}","vulnerability_type":"concurrency","scoring_criteria":[{"criterion":"identifies_concurrency_issue","points":2,"keywords":["concurrency","mutex","lock"]},{"criterion":"corrects_concurrency_issue","points":3,"check_function":"check_mutex_lock_usage"},{"criterion":"code_compiles","points":1,"check_function":"validate_go_code"}],"automated_tests":["test_deposit_withdraw"],"reference_solution":"package main\nimport \"sync\"\ntype BankAccount struct {\n    balance int\n    mu sync.Mutex\n}\nfunc (a *BankAccount) Deposit(amount int) {\n    a.mu.Lock()\n    a.balance += amount\n    a.mu.Unlock()\n}\nfunc (a *BankAccount) Withdraw(amount int) {\n    a.mu.Lock()\n    if a.balance >= amount {\n        a.balance -= amount\n    }\n    a.mu.Unlock()\n}"}
{"question_type":"code_audit","instructions":"Identify the ownership issue in the Rust contract and provide fixed code","contract_code":"struct Wallet {\n    balanceÔºö u32,\n}\nfn transfer(walletÔºö &WalletÔºå amountÔºö u32) {\n    wallet.balance -= amount;\n}","vulnerability_type":"ownership","scoring_criteria":[{"criterion":"identifies_ownership_issue","points":2,"keywords":["ownership","borrowing","reference"]},{"criterion":"corrects_ownership_issue","points":3,"check_function":"check_ownership_correction"},{"criterion":"code_compiles","points":1,"check_function":"validate_rust_code"}],"automated_tests":["test_transfer"],"reference_solution":"struct Wallet {\n    balanceÔºö u32,\n}\nfn transfer(walletÔºö &mut WalletÔºå amountÔºö u32) {\n    wallet.balance -= amount;\n}"} 
{"question_type": "code_audit", "title": "Solidity Re-entrancy (basic vault)", "instructions": "Identify the vulnerability and provide fixed code.", "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ncontract VulnerableBank {\n    mapping(address => uint256) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] >= amountÔºå \"Insufficient balance\");\n        (bool successÔºå ) = msg.sender.call{value: amount}(\"\");\n        require(successÔºå \"Transfer failed\");\n        balances[msg.sender] -= amount;\n    }\n}", "vulnerability_type": "reentrancy", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["reentrancy", "reentrant"]}, {"criterion": "follows_checks_effects_interactions", "points": 3, "check_function": "check_state_update_before_external_call"}, {"criterion": "implements_reentrancy_guard", "points": 2, "check_function": "check_reentrancy_guard"}, {"criterion": "code_compiles", "points": 1, "check_function": "validate_solidity_code"}], "automated_tests": ["test_deposit_withdraw_workflow", "test_reentrancy_attack_prevention"], "reference_solution": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SecureBank is ReentrancyGuard {\n    mapping(address => uint256) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external nonReentrant {\n        require(balances[msg.sender] >= amountÔºå \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        (bool successÔºå ) = msg.sender.call{value: amount}(\"\");\n        require(successÔºå \"Transfer failed\");\n    }\n}", "total_possible": 8}
{"question_type": "code_audit", "title": "ERC-777 / ERC-20 Callback Re-entrancy", "instructions": "Locate the vulnerability in the vault and supply a patched version.", "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract VulnerableVault is IERC777Recipient {\n    IERC20 public immutable token;\n    mapping(address => uint256) public deposits;\n\n    constructor(address _token) { token = IERC20(_token); }\n\n    // ERC-777 hook fires before balance update ‚Üí re-entrancy window\n    function tokensReceived(\n        addressÔºå address fromÔºå addressÔºå uint256 amountÔºå\n        bytes calldataÔºå bytes calldata\n    ) external override {\n        deposits[from] += amount;\n    }\n\n    function withdraw(uint256 amt) external {\n        require(deposits[msg.sender] >= amtÔºå \"not enough\");\n        token.transfer(msg.senderÔºå amt);     // external call first ‚áí re-entrancy\n        deposits[msg.sender] -= amt;\n    }\n}", "vulnerability_type": "reentrancy", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["reentrancy", "callback"]}, {"criterion": "follows_checks_effects_interactions", "points": 3, "check_function": "check_state_update_before_external_call"}, {"criterion": "implements_reentrancy_guard", "points": 2, "check_function": "check_reentrancy_guard"}, {"criterion": "code_compiles", "points": 1, "check_function": "validate_solidity_code"}], "automated_tests": ["test_deposit_withdraw", "test_callback_reentrancy"], "reference_solution": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SecureVault is IERC777RecipientÔºå ReentrancyGuard {\n    IERC20 public immutable token;\n    mapping(address => uint256) public deposits;\n\n    constructor(address _token) { token = IERC20(_token); }\n\n    function tokensReceived(\n        addressÔºå address fromÔºå addressÔºå uint256 amountÔºå\n        bytes calldataÔºå bytes calldata\n    ) external override {\n        deposits[from] += amount;           // state change first\n    }\n\n    function withdraw(uint256 amt) external nonReentrant {\n        require(deposits[msg.sender] >= amtÔºå \"not enough\");\n        deposits[msg.sender] -= amt;        // Effects\n        require(token.transfer(msg.senderÔºå amt)Ôºå \"transfer failed\"); // Interaction\n    }\n}", "total_possible": 8}
{"question_type": "code_audit", "title": "Predictable On-Chain Randomness", "instructions": "Explain why the randomness is predictable and provide a secure alternative.", "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ncontract PredictableLottery {\n    function draw() external view returns (uint256) {\n        return uint256(\n            keccak256(abi.encodePacked(blockhash(block.number - 1)Ôºå block.timestamp))\n        ) % 100; // miner-controlled input\n    }\n}", "vulnerability_type": "predictable_randomness", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["predictable", "randomness"]}, {"criterion": "implements_vrf_or_commit_reveal", "points": 3, "check_function": "check_secure_randomness"}, {"criterion": "code_compiles", "points": 1, "check_function": "validate_solidity_code"}], "automated_tests": ["test_unpredictable_draw"], "reference_solution": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\n\ncontract VRFLottery is VRFConsumerBase { /* VRF wiring omitted */ }", "total_possible": 6}
{"question_type": "code_audit", "title": "Rent-Exempt Bypass (Solana)", "instructions": "Demonstrate how a rent exemption bypass can be exploited in Solana account management and propose a solution. Your solution should include a code fix and the implementation of a validation check to prevent further exploitation of this vulnerability.", "contract_code": "// Attacker tops up lamports to appear rent-exemptÔºå then withdraws in the same slotÔºå bypassing the rent exemption check.", "vulnerability_type": "rent_exemption_spoof", "scoring_criteria": [{"criterion": "Identifies the Vulnerability Type", "points": 2, "keywords": ["rent", "exempt", "spoof"], "description": "The student must correctly identify the rent exemption spoof vulnerability in the provided contract codeÔºå demonstrating understanding of how attackers manipulate rent exemption status."}, {"criterion": "Adds Post-Instruction Check", "points": 3, "check_function": "check_rent_after_ops", "description": "The student must implement a validation check after critical operations to ensure that the account still meets the rent exemption criteria. This is done by calling sysvar::rent::check_reserve(&account) after every transfer."}, {"criterion": "Fix Implementation", "points": 4, "description": "The student should provide a code fix that prevents rent exemption spoofing. The solution must include a reliable check for rent exemption after the transaction and before any withdrawals can happen."}], "automated_tests": ["test_rent_exempt_validation", "test_account_rent_check_post_transaction"], "reference_solution": "// Code Fix: After all transfersÔºå validate the rent exemption status by invoking sysvar::rent::check_reserve(&account). If the account does not meet the rent exemption criteriaÔºå the transaction should fail.\n\nfn check_rent_after_ops(account: &Account) -> Result<()Ôºå &'static str> {\n  if !sysvar::rent::check_reserve(account) {\n    return Err(\"Account does not meet rent exemption criteria\");\n  }\n  Ok(())\n}", "total_possible": 9}
{"question_type": "code_audit", "title": "CosmWasm BankMsg Unlimited Send", "instructions": "Spot the unbounded token forward and cap the loss.", "contract_code": "// CosmWasm 1.3\npub fn execute_forward(\n    _deps: DepsMutÔºå\n    _info: MessageInfoÔºå\n    to: StringÔºå\n    amount: CoinÔºå\n) -> Result<ResponseÔºå StdError> {\n    let msg = cosmwasm_std::BankMsg::Send {\n        to_address: toÔºå\n        amount: vec![amount]Ôºå\n    }; // no upper limit or ACL\n    Ok(Response::new().add_message(msg))\n}", "vulnerability_type": "unbounded_transfer", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["unlimited", "drain"]}, {"criterion": "adds_amount_cap_or_acl", "points": 3, "check_function": "check_amount_limit"}], "automated_tests": ["test_max_transfer_cap"], "reference_solution": "Assert amount ‚â§ MAX_CAP and require sender is whitelisted before forwarding.", "total_possible": 5}
{"question_type": "code_audit", "title": "IBC Light-Client Verification Flaw", "instructions": "Describe the proof-height bug and harden the check.", "contract_code": "// Cosmos SDK 0.47\nif !client.verify_membership(storeÔºå proofÔºå proof_heightÔºå ...) {\n    // should compare with trusted_height but does not\n}", "vulnerability_type": "light_client_height_bypass", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["proof-height"]}, {"criterion": "enforces_monotonic_height", "points": 3, "check_function": "check_height_validation"}], "automated_tests": ["test_forged_packet_blocked"], "reference_solution": "Require proof_height ‚â• consensus_state.latest_height and ‚â§ trusted_height; prune expired consensus states.", "total_possible": 5}
{"question_type": "code_audit", "title": "MPC Threshold Signature Bypass", "instructions": "Analyse how inconsistent curve parameters break the threshold guarantee and lock them down.", "contract_code": "// Rust (simplified)\nstruct Share { curve_id: Option<u8>Ôºå r: ScalarÔºå s: Scalar }\n// Coordinator never verifies that all shares use the same curve_id", "vulnerability_type": "threshold_bypass", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["threshold", "bypass"]}, {"criterion": "binds_curve_params", "points": 3, "check_function": "check_curve_id"}], "automated_tests": ["test_threshold_enforcement"], "reference_solution": "Add curve domain separator to every share transcript and reject aggregation if any curve_id mismatches.", "total_possible": 5}
{"question_type": "code_audit", "title": "Solidity Unrestricted Self-Destruct", "instructions": "Show how anyone can destroy the contract and fix the access control.", "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ncontract BoomBox {\n    function boom(address payable receiver) external {\n        selfdestruct(receiver); // üî• unrestricted\n    }\n    receive() external payable {}\n}", "vulnerability_type": "unrestricted_selfdestruct", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["selfdestruct", "access"]}, {"criterion": "locks_down_or_removes_selfdestruct", "points": 3, "check_function": "check_only_owner"}, {"criterion": "code_compiles", "points": 1, "check_function": "validate_solidity_code"}], "automated_tests": ["test_selfdestruct_protection"], "reference_solution": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ncontract SafeBox {\n    address public immutable owner = msg.sender;\n    modifier onlyOwner { require(msg.sender == ownerÔºå \"not owner\"); _; }\n\n    function destroy(address payable receiver) external onlyOwner {\n        selfdestruct(receiver);\n    }\n    receive() external payable {}\n}", "total_possible": 6}
{"question_type": "code_audit", "instructions": "Analyze the provided Solidity contract for security vulnerabilities related to the use of delegatecall. Explain the risks associated with arbitrary delegatecall and propose a secure solution that restricts the callee to a trusted implementation. Consider using established patterns and libraries to enhance security.", "factors_to_consider": ["The risk of arbitrary delegatecall allowing unauthorized code execution", "The importance of restricting the implementation address to a trusted source", "The use of established proxy patterns and libraries like OpenZeppelin", "Gas efficiency and execution cost implications", "Potential edge cases and attack vectors specific to delegatecall"], "keywords": ["delegatecall", "proxy pattern", "OpenZeppelin", "trusted implementation", "smart contract security", "Solidity"], "expected_insights": ["Understanding of delegatecall risks and how they can lead to unauthorized state changes", "Knowledge of how to restrict the implementation address to prevent arbitrary delegatecall", "Familiarity with using OpenZeppelin's proxy contracts to enhance security", "Ability to identify and mitigate potential attack vectors in smart contract design"], "scoring_criteria": [{"criterion": "identifies_delegatecall_issue", "points": 2, "key_points": ["Recognizes the security risk of arbitrary delegatecall", "Explains potential consequences of the vulnerability"]}, {"criterion": "restricts_implementation_address", "points": 3, "key_points": ["Proposes a method to restrict the implementation address to a trusted source", "Demonstrates understanding of access control mechanisms"]}, {"criterion": "uses_secure_proxy_pattern", "points": 2, "key_points": ["Recommends using OpenZeppelin's proxy pattern", "Explains the benefits of using established libraries"]}], "total_possible": 7, "id": 9, "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n// A contract that can be used as a library for the main contract.\ncontract LibraryContract {\n    uint256 public value;\n\n    function setValue(uint256 _value) public {\n        value = _value;\n    }\n}\n\n// The main contract that uses delegatecall to call the library.\n// This contract is vulnerable because the library address can be changed by anyone.\ncontract VulnerableProxy {\n    address public implementation;\n    address public owner;\n\n    constructor(address _implementation) {\n        implementation = _implementation;\n        owner = msg.sender;\n    }\n\n    // The attacker can change the implementation address to a malicious contract.\n    function setImplementation(address _newImplementation) public {\n        implementation = _newImplementation;\n    }\n\n    // The fallback function that delegates calls to the implementation contract.\n    fallback() external payable {\n        (bool successÔºå bytes memory data) = implementation.delegatecall(msg.data);\n        require(successÔºå \"Delegatecall failed\");\n    }\n}\n"}
{"question_type": "code_audit", "instructions": "Analyze the provided Solidity contract to identify vulnerabilities related to ECDSA signature malleability. Demonstrate how an attacker could exploit the 's' value malleability to reuse permits. Implement a solution that enforces EIP-2 compliance by ensuring the 's' value is in the lower half of the secp256k1 curve and properly manages nonces to prevent replay attacks. Provide a detailed explanation of your approach and the security implications.", "factors_to_consider": ["ECDSA signature malleability", "EIP-2 compliance for 's' value", "Nonce management to prevent replay attacks", "Security implications of signature reuse", "Compatibility with existing ERC20 standards"], "keywords": ["ECDSA", "signature malleability", "EIP-2", "nonce management", "replay attack", "Solidity", "ERC20"], "expected_insights": ["Understanding of ECDSA signature structure and vulnerabilities", "Knowledge of EIP-2 and its importance in preventing malleability", "Ability to implement nonce management to enhance security", "Insight into how signature malleability can be exploited in smart contracts", "Technical proficiency in Solidity for implementing secure contracts"], "scoring_criteria": [{"criterion": "Identifies signature malleability vulnerability", "points": 2, "key_points": ["Correctly identifies the 's' value malleability issue", "Explains potential exploits using signature reuse"]}, {"criterion": "Implements EIP-2 compliance", "points": 3, "key_points": ["Ensures 's' value is in the lower half of the curve", "Explains the significance of EIP-2 compliance"]}, {"criterion": "Manages nonces effectively", "points": 2, "key_points": ["Implements nonce incrementation on successful permit", "Prevents replay attacks through nonce checks"]}, {"criterion": "Code compiles and functions correctly", "points": 1, "key_points": ["Code compiles without errors", "Passes provided automated tests"]}], "total_possible": 8, "id": 10, "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n// This contract is vulnerable to ECDSA signature malleability.\n// An attacker can submit a valid signature with a different `s` value.\ncontract VulnerableSignatureValidator {\n    address public signer;\n\n    constructor(address _signer) {\n        signer = _signer;\n    }\n\n    // This function is vulnerable because it does not check for a unique `s` value.\n    function isValidSignature(bytes32 messageÔºå bytes memory signature) public view returns (bool) {\n        return ECDSA.recover(messageÔºå signature) == signer;\n    }\n\n    // An attacker can use this function to replay a valid signature with a modified `s` value.\n    function execute(bytes32 messageÔºå bytes memory signature) public {\n        require(isValidSignature(messageÔºå signature)Ôºå \"Invalid signature\");\n        // Execute some action...\n    }\n}\n"}
{"question_type": "code_audit", "title": "Cairo Dictionary Key Collision", "instructions": "Identify the dictionary seed collision and propose deterministic namespacing.", "contract_code": "# Cairo 1.1\n@storage_var\ndef balances(key: felt) -> felt:\n    pass\n\n@external\ndef deposit{syscall_ptr: felt*Ôºå pedersen_ptr: HashBuiltin*Ôºå range_check_ptr}(user: feltÔºå amount: felt):\n    balances.write(userÔºå balances.read(user) + amount)\n\n# Multiple contracts deploying this code will share the same storage path for identical keys", "vulnerability_type": "storage_key_collision", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["collision", "storage", "dictionary"]}, {"criterion": "adds_contract_address_to_seed", "points": 3, "check_function": "check_unique_seed"}], "automated_tests": ["test_no_storage_overlap"], "reference_solution": "@storage_var\ndef balances(contract_address: feltÔºå key: felt) -> felt: pass  # include deployer address", "total_possible": 5}
{"question_type": "code_audit", "instructions": "Analyze the provided Solidity contract to identify potential vulnerabilities related to gas stipend limitations when using transfer(). Refactor the contract to use a safer ETH transfer patternÔºå such as call()Ôºå ensuring the contract remains secure and functional. Provide a detailed explanation of the changes made and why they address the identified issues.", "factors_to_consider": ["Impact of EIP-1884 on gas costs", "Differences between transfer()Ôºå send()Ôºå and call()", "Security implications of using call()", "Ensuring reentrancy safety"], "keywords": ["EIP-1884", "gas stipend", "transfer()", "call()", "reentrancy"], "expected_insights": ["Understanding of gas stipend limitations post-EIP-1884", "Ability to refactor code to use call() safely", "Knowledge of reentrancy vulnerabilities and prevention techniques"], "scoring_criteria": [{"criterion": "Identifies gas stipend vulnerability", "points": 2, "key_points": ["Mentions EIP-1884 impact", "Explains why transfer() can fail"]}, {"criterion": "Refactors to safe ETH transfer pattern", "points": 3, "key_points": ["Uses call() with proper checks", "Ensures reentrancy safety"]}, {"criterion": "Code compiles successfully", "points": 1, "key_points": ["No syntax errors", "Compiles with Solidity 0.8.22"]}], "total_possible": 6, "id": 12}
{"question_type": "code_audit", "title": "NEAR Promise Callback Re-entrancy", "instructions": "Demonstrate the re-entrancy window in the callback and defend against it.", "contract_code": "// Rust ‚Äì NEAR\n#[near_bindgen]\nimpl Contract {\n    #[payable]\n    pub fn lock(&mut self) {\n        let amount = env::attached_deposit();\n        Promise::new(self.vault.clone()).transfer(amount).then(\n            Promise::new(env::current_account_id()).function_call(\n                \"release\".to_string()Ôºå\n                vec![]Ôºå 0Ôºå Gas(50_000_000_000_000)\n            )\n        ); // state not updated until after the external transfer\n    }\n\n    pub fn release(&mut self) {\n        self.unlocked = true; // attacker re-enters before lock state set\n    }\n}", "vulnerability_type": "promise_reentrancy", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["promise", "reentrancy"]}, {"criterion": "moves_state_update_before_promise", "points": 3, "check_function": "check_effects_first"}], "automated_tests": ["test_promise_reentrancy_guard"], "reference_solution": "Set self.locked = true before issuing the Promise and require(!locked) in entry functions.", "total_possible": 5}
{"question_type": "code_audit", "instructions": "Identify the ownership issue in this token transfer contract and provide fixed code that properly handles mutable borrowing", "contract_code": "struct Token {\n    balances: std::collections::HashMap<StringÔºå u64>Ôºå\n}\n\nimpl Token {\n    fn transfer(&selfÔºå from: &strÔºå to: &strÔºå amount: u64) -> Result<()Ôºå &'static str> {\n        let from_balance = self.balances.get(from).ok_or(\"Account not found\")?;\n        if *from_balance < amount {\n            return Err(\"Insufficient balance\");\n        }\n        self.balances.insert(from.to_string()Ôºå from_balance - amount);\n        let to_balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(to.to_string()Ôºå to_balance + amount);\n        Ok(())\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "identifies_immutable_borrow", "points": 2, "keywords": ["immutable", "mutable", "self", "borrow"]}, {"criterion": "fixes_method_signature", "points": 3, "check_function": "check_mutable_self_correction"}, {"criterion": "maintains_functionality", "points": 1, "check_function": "validate_token_transfer"}], "automated_tests": ["test_token_transfer", "test_insufficient_balance"], "reference_solution": "struct Token {\n    balances: std::collections::HashMap<StringÔºå u64>Ôºå\n}\n\nimpl Token {\n    fn transfer(&mut selfÔºå from: &strÔºå to: &strÔºå amount: u64) -> Result<()Ôºå &'static str> {\n        let from_balance = self.balances.get(from).ok_or(\"Account not found\")?;\n        if *from_balance < amount {\n            return Err(\"Insufficient balance\");\n        }\n        self.balances.insert(from.to_string()Ôºå from_balance - amount);\n        let to_balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(to.to_string()Ôºå to_balance + amount);\n        Ok(())\n    }\n}", "id": 14}
{"question_type": "short_answer", "instructions": "Complete the smart contract voting system by implementing proper ownership patterns for vote delegation while avoiding move semantics issues", "contract_code": "struct Vote {\n    proposal_id: u32Ôºå\n    voter: StringÔºå\n    weight: u32Ôºå\n}\n\nstruct VotingSystem {\n    votes: Vec<Vote>Ôºå\n    delegates: std::collections::HashMap<StringÔºå String>Ôºå\n}\n\nimpl VotingSystem {\n    fn delegate_vote(&mut selfÔºå delegator: StringÔºå delegate: String) {\n        self.delegates.insert(delegatorÔºå delegate);\n    }\n    \n    fn cast_vote(&mut selfÔºå vote: Vote) {\n        let effective_voter = self.get_effective_voter(vote.voter);\n        let delegated_vote = Vote {\n            proposal_id: vote.proposal_idÔºå\n            voter: effective_voterÔºå\n            weight: vote.weightÔºå\n        };\n        self.votes.push(delegated_vote);\n    }\n    \n    fn get_effective_voter(&selfÔºå voter: String) -> String {\n        // TODO: Implement without ownership issues\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "implements_borrow_pattern", "points": 3, "keywords": ["borrow", "reference", "clone", "lifetime"]}, {"criterion": "avoids_move_semantics", "points": 2, "check_function": "check_no_unnecessary_moves"}, {"criterion": "handles_delegation_chain", "points": 2, "check_function": "validate_delegation_logic"}], "automated_tests": ["test_vote_delegation", "test_delegation_chain"], "reference_solution": "fn get_effective_voter(&selfÔºå voter: String) -> String {\n    match self.delegates.get(&voter) {\n        Some(delegate) => delegate.clone()Ôºå\n        None => voterÔºå\n    }\n}", "id": 15}
{"question_type": "short_answer", "instructions": "Optimize this asset management contract to eliminate unnecessary cloning and improve borrowing patterns for better performance", "contract_code": "struct Asset {\n    id: StringÔºå\n    owner: StringÔºå\n    metadata: std::collections::HashMap<StringÔºå String>Ôºå\n}\n\nstruct AssetRegistry {\n    assets: std::collections::HashMap<StringÔºå Asset>Ôºå\n}\n\nimpl AssetRegistry {\n    fn transfer_asset(&mut selfÔºå asset_id: StringÔºå new_owner: String) -> Result<()Ôºå &'static str> {\n        let asset = self.assets.get(&asset_id).ok_or(\"Asset not found\")?.clone();\n        let mut updated_asset = asset.clone();\n        updated_asset.owner = new_owner;\n        self.assets.insert(asset_idÔºå updated_asset);\n        Ok(())\n    }\n    \n    fn get_asset_owner(&selfÔºå asset_id: String) -> Option<String> {\n        self.assets.get(&asset_id).map(|asset| asset.owner.clone())\n    }\n    \n    fn update_metadata(&mut selfÔºå asset_id: StringÔºå key: StringÔºå value: String) -> Result<()Ôºå &'static str> {\n        let asset = self.assets.get(&asset_id).ok_or(\"Asset not found\")?.clone();\n        let mut updated_asset = asset;\n        updated_asset.metadata.insert(keyÔºå value);\n        self.assets.insert(asset_idÔºå updated_asset);\n        Ok(())\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "eliminates_unnecessary_cloning", "points": 1, "keywords": ["clone", "unnecessary", "reference"]}, {"criterion": "optimizes_mutable_access", "points": 4, "check_function": "check_direct_mutation"}, {"criterion": "improves_string_handling", "points": 2, "check_function": "validate_string_borrowing"}], "automated_tests": ["test_asset_transfer", "test_metadata_update"], "reference_solution": "impl AssetRegistry {\n    fn transfer_asset(&mut selfÔºå asset_id: &strÔºå new_owner: String) -> Result<()Ôºå &'static str> {\n        self.assets.get_mut(asset_id).ok_or(\"Asset not found\")?.owner = new_owner;\n        Ok(())\n    }\n    \n    fn get_asset_owner(&selfÔºå asset_id: &str) -> Option<&str> {\n        self.assets.get(asset_id).map(|asset| asset.owner.as_str())\n    }\n    \n    fn update_metadata(&mut selfÔºå asset_id: &strÔºå key: StringÔºå value: String) -> Result<()Ôºå &'static str> {\n        self.assets.get_mut(asset_id).ok_or(\"Asset not found\")?.metadata.insert(keyÔºå value);\n        Ok(())\n    }\n}", "id": 16}
{"question_type": "short_answer", "instructions": "Debug the failing test cases for this escrow contract by identifying and fixing the borrowing conflicts that prevent compilation", "contract_code": "struct Escrow {\n    funds: std::collections::HashMap<StringÔºå u64>Ôºå\n    pending_releases: Vec<String>Ôºå\n}\n\nimpl Escrow {\n    fn deposit(&mut selfÔºå account: StringÔºå amount: u64) {\n        let balance = self.funds.entry(account.clone()).or_insert(0);\n        *balance += amount;\n        self.pending_releases.push(account);\n    }\n    \n    fn release_funds(&mut selfÔºå account: &str) -> Result<u64Ôºå &'static str> {\n        let funds = self.funds.get(account).ok_or(\"No funds found\")?;\n        let amount = *funds;\n        self.funds.remove(account);\n        self.pending_releases.retain(|acc| acc != account);\n        Ok(amount)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_escrow_operations() {\n        let mut escrow = Escrow {\n            funds: std::collections::HashMap::new()Ôºå\n            pending_releases: Vec::new()Ôºå\n        };\n        \n        escrow.deposit(\"alice\".to_string()Ôºå 100);\n        let balance = escrow.funds.get(\"alice\").unwrap();\n        let pending = &escrow.pending_releases;\n        assert_eq!(*balanceÔºå 100);\n        assert!(pending.contains(&\"alice\".to_string()));\n        \n        let released = escrow.release_funds(\"alice\").unwrap();\n        assert_eq!(releasedÔºå 100);\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "identifies_borrow_conflict", "points": 2, "keywords": ["borrow", "conflict", "immutable", "mutable"]}, {"criterion": "fixes_test_borrowing", "points": 2, "check_function": "check_test_compilation"}, {"criterion": "maintains_test_logic", "points": 3, "check_function": "validate_test_assertions"}], "automated_tests": ["test_escrow_operations", "test_multiple_deposits"], "reference_solution": "#[test]\nfn test_escrow_operations() {\n    let mut escrow = Escrow {\n        funds: std::collections::HashMap::new()Ôºå\n        pending_releases: Vec::new()Ôºå\n    };\n    \n    escrow.deposit(\"alice\".to_string()Ôºå 100);\n    {\n        let balance = escrow.funds.get(\"alice\").unwrap();\n        assert_eq!(*balanceÔºå 100);\n    }\n    assert!(escrow.pending_releases.contains(&\"alice\".to_string()));\n    \n    let released = escrow.release_funds(\"alice\").unwrap();\n    assert_eq!(releasedÔºå 100);\n}", "id": 17}
{"question_type": "short_answer", "instructions": "Refactor this monolithic smart contract into a modular architecture using the Strategy pattern for different token distribution mechanisms. Implement proper trait abstractions and demonstrate how to swap distribution strategies at runtime.", "contract_code": "struct TokenDistributor {\n    balance: u64Ôºå\n    distribution_type: StringÔºå\n}\n\nimpl TokenDistributor {\n    fn distribute(&mut selfÔºå amount: u64Ôºå recipients: Vec<String>) -> Result<()Ôºå String> {\n        if self.distribution_type == \"equal\" {\n            let per_recipient = amount / recipients.len() as u64;\n            self.balance -= amount;\n            println!(\"Equal distribution: {} per recipient\"Ôºå per_recipient);\n        } else if self.distribution_type == \"weighted\" {\n            // Hardcoded weighted logic\n            self.balance -= amount;\n            println!(\"Weighted distribution\");\n        } else if self.distribution_type == \"lottery\" {\n            // Hardcoded lottery logic\n            self.balance -= amount;\n            println!(\"Lottery distribution\");\n        }\n        Ok(())\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "implements_trait_abstraction", "points": 3, "keywords": ["trait", "strategy", "abstraction"]}, {"criterion": "demonstrates_modular_architecture", "points": 2, "keywords": ["modular", "separation", "decoupled"]}, {"criterion": "enables_runtime_strategy_swapping", "points": 2, "check_function": "check_strategy_swapping"}], "automated_tests": ["test_strategy_pattern", "test_runtime_swapping"], "reference_solution": "trait DistributionStrategy {\n    fn distribute(&selfÔºå amount: u64Ôºå recipients: &[String]) -> Result<()Ôºå String>;\n}\n\nstruct EqualDistribution;\nstruct WeightedDistribution;\nstruct LotteryDistribution;\n\nimpl DistributionStrategy for EqualDistribution {\n    fn distribute(&selfÔºå amount: u64Ôºå recipients: &[String]) -> Result<()Ôºå String> {\n        let per_recipient = amount / recipients.len() as u64;\n        println!(\"Equal: {} per recipient\"Ôºå per_recipient);\n        Ok(())\n    }\n}\n\nstruct TokenDistributor {\n    balance: u64Ôºå\n    strategy: Box<dyn DistributionStrategy>Ôºå\n}\n\nimpl TokenDistributor {\n    fn set_strategy(&mut selfÔºå strategy: Box<dyn DistributionStrategy>) {\n        self.strategy = strategy;\n    }\n    \n    fn distribute(&mut selfÔºå amount: u64Ôºå recipients: Vec<String>) -> Result<()Ôºå String> {\n        if self.balance < amount {\n            return Err(\"Insufficient balance\".to_string());\n        }\n        self.balance -= amount;\n        self.strategy.distribute(amountÔºå &recipients)\n    }\n}", "id": 18}
{"question_type": "code_audit", "instructions": "This contract attempts to implement a Factory pattern for creating different types of accountsÔºå but has critical ownership and lifetime issues. Identify the problems and provide a corrected implementation that properly manages object lifetimes and ownership.", "contract_code": "struct Account {\n    id: u32Ôºå\n    balance: u64Ôºå\n    account_type: StringÔºå\n}\n\nstruct AccountFactory {\n    created_accounts: Vec<&Account>Ôºå\n}\n\nimpl AccountFactory {\n    fn new() -> Self {\n        AccountFactory {\n            created_accounts: Vec::new()Ôºå\n        }\n    }\n    \n    fn create_account(&mut selfÔºå id: u32Ôºå account_type: String) -> &Account {\n        let account = Account {\n            idÔºå\n            balance: 0Ôºå\n            account_typeÔºå\n        };\n        self.created_accounts.push(&account);\n        &account\n    }\n    \n    fn get_account(&selfÔºå id: u32) -> Option<&Account> {\n        self.created_accounts.iter().find(|acc| acc.id == id).copied()\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "identifies_lifetime_issues", "points": 2, "keywords": ["lifetime", "dangling", "reference"]}, {"criterion": "fixes_ownership_model", "points": 4, "check_function": "check_ownership_fix"}, {"criterion": "maintains_factory_pattern", "points": 1, "keywords": ["factory", "pattern"]}], "automated_tests": ["test_factory_creation", "test_account_retrieval"], "reference_solution": "struct Account {\n    id: u32Ôºå\n    balance: u64Ôºå\n    account_type: StringÔºå\n}\n\nstruct AccountFactory {\n    created_accounts: Vec<Account>Ôºå\n}\n\nimpl AccountFactory {\n    fn new() -> Self {\n        AccountFactory {\n            created_accounts: Vec::new()Ôºå\n        }\n    }\n    \n    fn create_account(&mut selfÔºå id: u32Ôºå account_type: String) -> &Account {\n        let account = Account {\n            idÔºå\n            balance: 0Ôºå\n            account_typeÔºå\n        };\n        self.created_accounts.push(account);\n        self.created_accounts.last().unwrap()\n    }\n    \n    fn get_account(&selfÔºå id: u32) -> Option<&Account> {\n        self.created_accounts.iter().find(|acc| acc.id == id)\n    }\n}", "id": 19}
{"question_type": "short_answer", "instructions": "Optimize this Observer pattern implementation for a smart contract event system. The current design has performance issues with event notification and memory usage. Refactor to use efficient data structures and minimize allocations while maintaining the observer pattern's flexibility.", "contract_code": "use std::collections::HashMap;\n\ntrait EventObserver {\n    fn on_event(&selfÔºå event: StringÔºå data: HashMap<StringÔºå String>);\n}\n\nstruct ContractEventSystem {\n    observers: HashMap<StringÔºå Vec<Box<dyn EventObserver>>>Ôºå\n    event_history: Vec<(StringÔºå HashMap<StringÔºå String>)>Ôºå\n}\n\nimpl ContractEventSystem {\n    fn new() -> Self {\n        ContractEventSystem {\n            observers: HashMap::new()Ôºå\n            event_history: Vec::new()Ôºå\n        }\n    }\n    \n    fn subscribe(&mut selfÔºå event_type: StringÔºå observer: Box<dyn EventObserver>) {\n        self.observers.entry(event_type).or_insert_with(Vec::new).push(observer);\n    }\n    \n    fn emit_event(&mut selfÔºå event_type: StringÔºå data: HashMap<StringÔºå String>) {\n        // Store full event history (memory intensive)\n        self.event_history.push((event_type.clone()Ôºå data.clone()));\n        \n        // Notify all observers (inefficient cloning)\n        if let Some(observers) = self.observers.get(&event_type) {\n            for observer in observers {\n                observer.on_event(event_type.clone()Ôºå data.clone());\n            }\n        }\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "optimizes_memory_usage", "points": 2, "keywords": ["memory", "allocation", "efficient"]}, {"criterion": "reduces_clone_operations", "points": 2, "keywords": ["clone", "borrow", "reference"]}, {"criterion": "maintains_observer_pattern", "points": 3, "check_function": "check_observer_pattern"}], "automated_tests": ["test_optimized_notifications", "test_memory_efficiency"], "reference_solution": "use std::collections::HashMap;\nuse std::rc::Rc;\n\ntrait EventObserver {\n    fn on_event(&selfÔºå event: &strÔºå data: &HashMap<StringÔºå String>);\n}\n\nstruct EventData {\n    event_type: StringÔºå\n    data: HashMap<StringÔºå String>Ôºå\n}\n\nstruct ContractEventSystem {\n    observers: HashMap<StringÔºå Vec<Rc<dyn EventObserver>>>Ôºå\n    event_history: Vec<Rc<EventData>>Ôºå\n    max_history: usizeÔºå\n}\n\nimpl ContractEventSystem {\n    fn new(max_history: usize) -> Self {\n        ContractEventSystem {\n            observers: HashMap::new()Ôºå\n            event_history: Vec::new()Ôºå\n            max_historyÔºå\n        }\n    }\n    \n    fn subscribe(&mut selfÔºå event_type: StringÔºå observer: Rc<dyn EventObserver>) {\n        self.observers.entry(event_type).or_insert_with(Vec::new).push(observer);\n    }\n    \n    fn emit_event(&mut selfÔºå event_type: StringÔºå data: HashMap<StringÔºå String>) {\n        let event_data = Rc::new(EventData { event_type: event_type.clone()Ôºå data });\n        \n        // Bounded history to prevent memory leaks\n        if self.event_history.len() >= self.max_history {\n            self.event_history.remove(0);\n        }\n        self.event_history.push(event_data.clone());\n        \n        // Efficient notification using references\n        if let Some(observers) = self.observers.get(&event_type) {\n            for observer in observers {\n                observer.on_event(&event_data.event_typeÔºå &event_data.data);\n            }\n        }\n    }\n}", "id": 20}
{"question_type": "refactoring", "instructions": "Refactor this tightly coupled smart contract system into a cleanÔºå modular architecture using dependency injection and the Command pattern. The current implementation violates single responsibility principle and makes testing difficult. Implement proper abstractions and demonstrate how the new design improves maintainability.", "contract_code": "struct WalletManager {\n    balances: std::collections::HashMap<StringÔºå u64>Ôºå\n    transaction_log: Vec<String>Ôºå\n}\n\nimpl WalletManager {\n    fn new() -> Self {\n        WalletManager {\n            balances: std::collections::HashMap::new()Ôºå\n            transaction_log: Vec::new()Ôºå\n        }\n    }\n    \n    fn transfer(&mut selfÔºå from: StringÔºå to: StringÔºå amount: u64) -> Result<()Ôºå String> {\n        // Validation logic mixed with business logic\n        if amount == 0 {\n            return Err(\"Amount must be positive\".to_string());\n        }\n        \n        let from_balance = self.balances.get(&from).unwrap_or(&0);\n        if *from_balance < amount {\n            return Err(\"Insufficient funds\".to_string());\n        }\n        \n        // Direct state manipulation\n        self.balances.insert(from.clone()Ôºå from_balance - amount);\n        let to_balance = self.balances.get(&to).unwrap_or(&0);\n        self.balances.insert(to.clone()Ôºå to_balance + amount);\n        \n        // Logging tightly coupled\n        self.transaction_log.push(format!(\"Transfer: {} -> {}: {}\"Ôºå fromÔºå toÔºå amount));\n        \n        // Hardcoded notification\n        println!(\"Transfer completed: {} to {}\"Ôºå fromÔºå to);\n        \n        Ok(())\n    }\n    \n    fn get_balance(&selfÔºå account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "implements_dependency_injection", "points": 1, "keywords": ["dependency", "injection", "decoupled"]}, {"criterion": "applies_command_pattern", "points": 4, "check_function": "check_command_pattern"}, {"criterion": "separates_concerns", "points": 2, "keywords": ["separation", "responsibility", "modular"]}], "automated_tests": ["test_command_execution", "test_dependency_injection"], "reference_solution": "use std::collections::HashMap;\n\ntrait BalanceStore {\n    fn get_balance(&selfÔºå account: &str) -> u64;\n    fn set_balance(&mut selfÔºå account: &strÔºå amount: u64);\n}\n\ntrait TransactionLogger {\n    fn log(&mut selfÔºå message: String);\n}\n\ntrait NotificationService {\n    fn notify(&selfÔºå message: String);\n}\n\nstruct InMemoryBalanceStore {\n    balances: HashMap<StringÔºå u64>Ôºå\n}\n\nimpl BalanceStore for InMemoryBalanceStore {\n    fn get_balance(&selfÔºå account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n    \n    fn set_balance(&mut selfÔºå account: &strÔºå amount: u64) {\n        self.balances.insert(account.to_string()Ôºå amount);\n    }\n}\n\ntrait Command {\n    fn execute(&selfÔºå wallet: &mut WalletManager) -> Result<()Ôºå String>;\n}\n\nstruct TransferCommand {\n    from: StringÔºå\n    to: StringÔºå\n    amount: u64Ôºå\n}\n\nimpl Command for TransferCommand {\n    fn execute(&selfÔºå wallet: &mut WalletManager) -> Result<()Ôºå String> {\n        wallet.transfer(self.from.clone()Ôºå self.to.clone()Ôºå self.amount)\n    }\n}\n\nstruct WalletManager {\n    balance_store: Box<dyn BalanceStore>Ôºå\n    logger: Box<dyn TransactionLogger>Ôºå\n    notifier: Box<dyn NotificationService>Ôºå\n}\n\nimpl WalletManager {\n    fn new(balance_store: Box<dyn BalanceStore>Ôºå logger: Box<dyn TransactionLogger>Ôºå notifier: Box<dyn NotificationService>) -> Self {\n        WalletManager { balance_storeÔºå loggerÔºå notifier }\n    }\n    \n    fn transfer(&mut selfÔºå from: StringÔºå to: StringÔºå amount: u64) -> Result<()Ôºå String> {\n        if amount == 0 {\n            return Err(\"Amount must be positive\".to_string());\n        }\n        \n        let from_balance = self.balance_store.get_balance(&from);\n        if from_balance < amount {\n            return Err(\"Insufficient funds\".to_string());\n        }\n        \n        self.balance_store.set_balance(&fromÔºå from_balance - amount);\n        let to_balance = self.balance_store.get_balance(&to);\n        self.balance_store.set_balance(&toÔºå to_balance + amount);\n        \n        self.logger.log(format!(\"Transfer: {} -> {}: {}\"Ôºå fromÔºå toÔºå amount));\n        self.notifier.notify(format!(\"Transfer completed: {} to {}\"Ôºå fromÔºå to));\n        \n        Ok(())\n    }\n    \n    fn execute_command(&mut selfÔºå command: Box<dyn Command>) -> Result<()Ôºå String> {\n        command.execute(self)\n    }\n}", "id": 21}
{"question_type": "short_answer", "instructions": "Optimize this inefficient token transfer function that clones vectors unnecessarily and uses inappropriate data structures for performance", "contract_code": "use std::collections::HashMap;\n\n#[derive(Clone)]\nstruct Transaction {\n    from: StringÔºå\n    to: StringÔºå\n    amount: u64Ôºå\n}\n\nstruct TokenContract {\n    balances: HashMap<StringÔºå u64>Ôºå\n    transactions: Vec<Transaction>Ôºå\n}\n\nimpl TokenContract {\n    fn transfer(&mut selfÔºå from: StringÔºå to: StringÔºå amount: u64) -> Result<()Ôºå String> {\n        let mut temp_transactions = self.transactions.clone();\n        let tx = Transaction { from: from.clone()Ôºå to: to.clone()Ôºå amount };\n        temp_transactions.push(tx.clone());\n        \n        if let Some(from_balance) = self.balances.get(&from) {\n            if *from_balance >= amount {\n                self.balances.insert(from.clone()Ôºå from_balance - amount);\n                let to_balance = self.balances.get(&to).unwrap_or(&0);\n                self.balances.insert(to.clone()Ôºå to_balance + amount);\n                self.transactions = temp_transactions;\n                Ok(())\n            } else {\n                Err(\"Insufficient balance\".to_string())\n            }\n        } else {\n            Err(\"Account not found\".to_string())\n        }\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "eliminates_unnecessary_cloning", "points": 3, "keywords": ["clone", "unnecessary", "borrow", "reference"]}, {"criterion": "optimizes_data_structures", "points": 2, "keywords": ["HashMap", "entry", "or_insert", "get_mut"]}, {"criterion": "improves_memory_efficiency", "points": 2, "check_function": "check_memory_short_answer"}], "automated_tests": ["test_transfer_performance", "test_memory_usage"], "reference_solution": "use std::collections::HashMap;\n\n#[derive(Clone)]\nstruct Transaction {\n    from: StringÔºå\n    to: StringÔºå\n    amount: u64Ôºå\n}\n\nstruct TokenContract {\n    balances: HashMap<StringÔºå u64>Ôºå\n    transactions: Vec<Transaction>Ôºå\n}\n\nimpl TokenContract {\n    fn transfer(&mut selfÔºå from: &strÔºå to: &strÔºå amount: u64) -> Result<()Ôºå String> {\n        let from_balance = self.balances.entry(from.to_string()).or_insert(0);\n        if *from_balance >= amount {\n            *from_balance -= amount;\n            *self.balances.entry(to.to_string()).or_insert(0) += amount;\n            self.transactions.push(Transaction { \n                from: from.to_string()Ôºå \n                to: to.to_string()Ôºå \n                amount \n            });\n            Ok(())\n        } else {\n            Err(\"Insufficient balance\".to_string())\n        }\n    }\n}", "id": 22}
{"question_type": "code_audit", "instructions": "Identify and fix the resource management issue in this contract that causes memory leaks and inefficient resource usage", "contract_code": "use std::collections::BTreeMap;\n\nstruct DataStorage {\n    id: u64Ôºå\n    data: Vec<u8>Ôºå\n    metadata: StringÔºå\n}\n\nstruct StorageContract {\n    storage_map: BTreeMap<u64Ôºå DataStorage>Ôºå\n    next_id: u64Ôºå\n}\n\nimpl StorageContract {\n    fn new() -> Self {\n        Self {\n            storage_map: BTreeMap::new()Ôºå\n            next_id: 1Ôºå\n        }\n    }\n    \n    fn store_data(&mut selfÔºå data: Vec<u8>Ôºå metadata: String) -> u64 {\n        let id = self.next_id;\n        self.next_id += 1;\n        \n        let storage = DataStorage {\n            idÔºå\n            data: data.clone()Ôºå\n            metadata: metadata.clone()Ôºå\n        };\n        \n        self.storage_map.insert(idÔºå storage);\n        id\n    }\n    \n    fn get_data(&selfÔºå id: u64) -> Option<Vec<u8>> {\n        self.storage_map.get(&id).map(|storage| storage.data.clone())\n    }\n    \n    fn update_metadata(&mut selfÔºå id: u64Ôºå new_metadata: String) -> bool {\n        if let Some(storage) = self.storage_map.get_mut(&id) {\n            storage.metadata = new_metadata.clone();\n            true\n        } else {\n            false\n        }\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "identifies_memory_leak", "points": 2, "keywords": ["clone", "memory", "leak", "unnecessary"]}, {"criterion": "fixes_resource_management", "points": 4, "check_function": "check_resource_short_answer"}, {"criterion": "maintains_functionality", "points": 1, "check_function": "validate_storage_contract"}], "automated_tests": ["test_storage_operations", "test_memory_efficiency"], "reference_solution": "use std::collections::BTreeMap;\n\nstruct DataStorage {\n    id: u64Ôºå\n    data: Vec<u8>Ôºå\n    metadata: StringÔºå\n}\n\nstruct StorageContract {\n    storage_map: BTreeMap<u64Ôºå DataStorage>Ôºå\n    next_id: u64Ôºå\n}\n\nimpl StorageContract {\n    fn new() -> Self {\n        Self {\n            storage_map: BTreeMap::new()Ôºå\n            next_id: 1Ôºå\n        }\n    }\n    \n    fn store_data(&mut selfÔºå data: Vec<u8>Ôºå metadata: String) -> u64 {\n        let id = self.next_id;\n        self.next_id += 1;\n        \n        let storage = DataStorage { idÔºå dataÔºå metadata };\n        self.storage_map.insert(idÔºå storage);\n        id\n    }\n    \n    fn get_data(&selfÔºå id: u64) -> Option<&Vec<u8>> {\n        self.storage_map.get(&id).map(|storage| &storage.data)\n    }\n    \n    fn update_metadata(&mut selfÔºå id: u64Ôºå new_metadata: String) -> bool {\n        if let Some(storage) = self.storage_map.get_mut(&id) {\n            storage.metadata = new_metadata;\n            true\n        } else {\n            false\n        }\n    }\n}", "id": 23}
{"question_type": "short_answer", "instructions": "Implement an efficient object pool pattern for this smart contract to reduce allocation overhead and improve performance for frequently created/destroyed objects", "contract_code": "struct Order {\n    id: u64Ôºå\n    user_id: u64Ôºå\n    amount: u64Ôºå\n    price: u64Ôºå\n    is_active: boolÔºå\n}\n\nstruct OrderBook {\n    orders: Vec<Order>Ôºå\n    next_id: u64Ôºå\n}\n\nimpl OrderBook {\n    fn new() -> Self {\n        Self {\n            orders: Vec::new()Ôºå\n            next_id: 1Ôºå\n        }\n    }\n    \n    fn create_order(&mut selfÔºå user_id: u64Ôºå amount: u64Ôºå price: u64) -> u64 {\n        let order = Order {\n            id: self.next_idÔºå\n            user_idÔºå\n            amountÔºå\n            priceÔºå\n            is_active: trueÔºå\n        };\n        self.next_id += 1;\n        self.orders.push(order);\n        self.next_id - 1\n    }\n    \n    fn cancel_order(&mut selfÔºå order_id: u64) -> bool {\n        if let Some(order) = self.orders.iter_mut().find(|o| o.id == order_id) {\n            order.is_active = false;\n            true\n        } else {\n            false\n        }\n    }\n    \n    fn cleanup_inactive_orders(&mut self) {\n        self.orders.retain(|order| order.is_active);\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "implements_object_pool", "points": 1, "keywords": ["pool", "reuse", "allocate", "deallocate"]}, {"criterion": "reduces_allocation_overhead", "points": 2, "keywords": ["allocation", "overhead", "performance", "efficiency"]}, {"criterion": "maintains_memory_efficiency", "points": 3, "check_function": "check_pool_implementation"}], "automated_tests": ["test_object_pool_performance", "test_order_lifecycle"], "reference_solution": "struct Order {\n    id: u64Ôºå\n    user_id: u64Ôºå\n    amount: u64Ôºå\n    price: u64Ôºå\n    is_active: boolÔºå\n}\n\nstruct OrderPool {\n    available: Vec<Order>Ôºå\n    capacity: usizeÔºå\n}\n\nimpl OrderPool {\n    fn new(capacity: usize) -> Self {\n        Self {\n            available: Vec::with_capacity(capacity)Ôºå\n            capacityÔºå\n        }\n    }\n    \n    fn get_order(&mut selfÔºå id: u64Ôºå user_id: u64Ôºå amount: u64Ôºå price: u64) -> Order {\n        if let Some(mut order) = self.available.pop() {\n            order.id = id;\n            order.user_id = user_id;\n            order.amount = amount;\n            order.price = price;\n            order.is_active = true;\n            order\n        } else {\n            Order { idÔºå user_idÔºå amountÔºå priceÔºå is_active: true }\n        }\n    }\n    \n    fn return_order(&mut selfÔºå order: Order) {\n        if self.available.len() < self.capacity {\n            self.available.push(order);\n        }\n    }\n}\n\nstruct OrderBook {\n    active_orders: Vec<Order>Ôºå\n    order_pool: OrderPoolÔºå\n    next_id: u64Ôºå\n}\n\nimpl OrderBook {\n    fn new() -> Self {\n        Self {\n            active_orders: Vec::new()Ôºå\n            order_pool: OrderPool::new(100)Ôºå\n            next_id: 1Ôºå\n        }\n    }\n    \n    fn create_order(&mut selfÔºå user_id: u64Ôºå amount: u64Ôºå price: u64) -> u64 {\n        let order = self.order_pool.get_order(self.next_idÔºå user_idÔºå amountÔºå price);\n        self.next_id += 1;\n        self.active_orders.push(order);\n        self.next_id - 1\n    }\n    \n    fn cancel_order(&mut selfÔºå order_id: u64) -> bool {\n        if let Some(pos) = self.active_orders.iter().position(|o| o.id == order_id) {\n            let order = self.active_orders.remove(pos);\n            self.order_pool.return_order(order);\n            true\n        } else {\n            false\n        }\n    }\n}", "id": 24}
{"question_type": "short_answer", "instructions": "Optimize this batch processing function to handle large datasets efficiently without causing stack overflow or excessive memory usage", "contract_code": "use std::collections::HashMap;\n\nstruct BatchProcessor {\n    data_cache: HashMap<StringÔºå Vec<u64>>Ôºå\n    results: Vec<ProcessingResult>Ôºå\n}\n\nstruct ProcessingResult {\n    key: StringÔºå\n    sum: u64Ôºå\n    count: usizeÔºå\n    average: f64Ôºå\n}\n\nimpl BatchProcessor {\n    fn new() -> Self {\n        Self {\n            data_cache: HashMap::new()Ôºå\n            results: Vec::new()Ôºå\n        }\n    }\n    \n    fn process_batch(&mut selfÔºå batch_data: Vec<(StringÔºå Vec<u64>)>) -> Vec<ProcessingResult> {\n        let mut results = Vec::new();\n        \n        for (keyÔºå values) in batch_data {\n            // Store in cache\n            self.data_cache.insert(key.clone()Ôºå values.clone());\n            \n            // Process immediately\n            let sum: u64 = values.iter().sum();\n            let count = values.len();\n            let average = sum as f64 / count as f64;\n            \n            let result = ProcessingResult {\n                key: key.clone()Ôºå\n                sumÔºå\n                countÔºå\n                averageÔºå\n            };\n            \n            results.push(result.clone());\n            self.results.push(result);\n        }\n        \n        results\n    }\n    \n    fn get_cached_data(&selfÔºå key: &str) -> Option<Vec<u64>> {\n        self.data_cache.get(key).cloned()\n    }\n    \n    fn clear_cache(&mut self) {\n        self.data_cache.clear();\n        self.results.clear();\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "eliminates_unnecessary_cloning", "points": 2, "keywords": ["clone", "reference", "borrow", "move"]}, {"criterion": "optimizes_batch_processing", "points": 2, "keywords": ["iterator", "chunks", "streaming", "batch"]}, {"criterion": "improves_memory_management", "points": 3, "check_function": "check_batch_short_answer"}], "automated_tests": ["test_large_batch_processing", "test_memory_usage_short_answer"], "reference_solution": "use std::collections::HashMap;\n\nstruct BatchProcessor {\n    data_cache: HashMap<StringÔºå Vec<u64>>Ôºå\n    results: Vec<ProcessingResult>Ôºå\n}\n\nstruct ProcessingResult {\n    key: StringÔºå\n    sum: u64Ôºå\n    count: usizeÔºå\n    average: f64Ôºå\n}\n\nimpl BatchProcessor {\n    fn new() -> Self {\n        Self {\n            data_cache: HashMap::new()Ôºå\n            results: Vec::new()Ôºå\n        }\n    }\n    \n    fn process_batch(&mut selfÔºå batch_data: Vec<(StringÔºå Vec<u64>)>) -> Vec<ProcessingResult> {\n        let mut results = Vec::with_capacity(batch_data.len());\n        \n        for (keyÔºå values) in batch_data {\n            let sum: u64 = values.iter().sum();\n            let count = values.len();\n            let average = sum as f64 / count as f64;\n            \n            let result = ProcessingResult {\n                key: key.clone()Ôºå\n                sumÔºå\n                countÔºå\n                averageÔºå\n            };\n            \n            results.push(result);\n            self.data_cache.insert(keyÔºå values);\n        }\n        \n        self.results.extend(results.iter().cloned());\n        results\n    }\n    \n    fn get_cached_data(&selfÔºå key: &str) -> Option<&Vec<u64>> {\n        self.data_cache.get(key)\n    }\n    \n    fn process_streaming(&mut selfÔºå data_stream: impl Iterator<Item = (StringÔºå Vec<u64>)>) -> impl Iterator<Item = ProcessingResult> + '_ {\n        data_stream.map(|(keyÔºå values)| {\n            let sum: u64 = values.iter().sum();\n            let count = values.len();\n            let average = sum as f64 / count as f64;\n            \n            let result = ProcessingResult { key: key.clone()Ôºå sumÔºå countÔºå average };\n            self.data_cache.insert(keyÔºå values);\n            result\n        })\n    }\n    \n    fn clear_cache(&mut self) {\n        self.data_cache.clear();\n        self.results.clear();\n    }\n}", "id": 25}
{"question_type": "short_answer", "instructions": "Write comprehensive unit tests for this token contract focusing on edge cases and proper error handling. Identify any missing test scenarios.", "contract_code": "use std::collections::HashMap;\n\n#[derive(DebugÔºå PartialEq)]\npub enum TokenError {\n    InsufficientBalanceÔºå\n    InvalidAmountÔºå\n}\n\npub struct Token {\n    balances: HashMap<StringÔºå u64>Ôºå\n    total_supply: u64Ôºå\n}\n\nimpl Token {\n    pub fn new(initial_supply: u64) -> Self {\n        let mut balances = HashMap::new();\n        balances.insert(\"owner\".to_string()Ôºå initial_supply);\n        Token { balancesÔºå total_supply: initial_supply }\n    }\n    \n    pub fn transfer(&mut selfÔºå from: &strÔºå to: &strÔºå amount: u64) -> Result<()Ôºå TokenError> {\n        if amount == 0 { return Err(TokenError::InvalidAmount); }\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        if *from_balance < amount { return Err(TokenError::InsufficientBalance); }\n        \n        self.balances.insert(from.to_string()Ôºå from_balance - amount);\n        let to_balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(to.to_string()Ôºå to_balance + amount);\n        Ok(())\n    }\n    \n    pub fn balance(&selfÔºå account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n}", "vulnerability_type": "error_handling", "scoring_criteria": [{"criterion": "tests_edge_cases", "points": 3, "keywords": ["zero_amount", "nonexistent_account", "overflow"]}, {"criterion": "proper_test_structure", "points": 2, "keywords": ["#[test]", "assert_eq", "assert"]}, {"criterion": "error_handling_tests", "points": 2, "keywords": ["Result", "unwrap", "expect", "match"]}], "automated_tests": ["test_token_functionality", "test_error_scenarios"], "reference_solution": "#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_transfer_success() {\n        let mut token = Token::new(1000);\n        assert!(token.transfer(\"owner\"Ôºå \"alice\"Ôºå 100).is_ok());\n        assert_eq!(token.balance(\"alice\")Ôºå 100);\n        assert_eq!(token.balance(\"owner\")Ôºå 900);\n    }\n    \n    #[test]\n    fn test_insufficient_balance() {\n        let mut token = Token::new(1000);\n        assert_eq!(token.transfer(\"alice\"Ôºå \"bob\"Ôºå 100)Ôºå Err(TokenError::InsufficientBalance));\n    }\n    \n    #[test]\n    fn test_zero_amount_transfer() {\n        let mut token = Token::new(1000);\n        assert_eq!(token.transfer(\"owner\"Ôºå \"alice\"Ôºå 0)Ôºå Err(TokenError::InvalidAmount));\n    }\n}", "id": 26}
{"question_type": "code_audit", "instructions": "Identify the integer overflow vulnerability in this staking contract and provide a secure implementation with proper overflow checks.", "contract_code": "use std::collections::HashMap;\n\npub struct StakingPool {\n    stakes: HashMap<StringÔºå u64>Ôºå\n    rewards: HashMap<StringÔºå u64>Ôºå\n    reward_rate: u64Ôºå\n}\n\nimpl StakingPool {\n    pub fn new(reward_rate: u64) -> Self {\n        StakingPool {\n            stakes: HashMap::new()Ôºå\n            rewards: HashMap::new()Ôºå\n            reward_rateÔºå\n        }\n    }\n    \n    pub fn stake(&mut selfÔºå user: &strÔºå amount: u64) {\n        let current_stake = self.stakes.get(user).unwrap_or(&0);\n        self.stakes.insert(user.to_string()Ôºå current_stake + amount);\n    }\n    \n    pub fn calculate_rewards(&mut selfÔºå user: &strÔºå time_elapsed: u64) {\n        let stake_amount = self.stakes.get(user).unwrap_or(&0);\n        let reward = stake_amount * self.reward_rate * time_elapsed / 100;\n        let current_rewards = self.rewards.get(user).unwrap_or(&0);\n        self.rewards.insert(user.to_string()Ôºå current_rewards + reward);\n    }\n    \n    pub fn get_stake(&selfÔºå user: &str) -> u64 {\n        *self.stakes.get(user).unwrap_or(&0)\n    }\n    \n    pub fn get_rewards(&selfÔºå user: &str) -> u64 {\n        *self.rewards.get(user).unwrap_or(&0)\n    }\n}", "vulnerability_type": "integer_overflow", "scoring_criteria": [{"criterion": "identifies_overflow_vulnerability", "points": 2, "keywords": ["overflow", "saturating", "checked"]}, {"criterion": "implements_safe_arithmetic", "points": 4, "check_function": "check_overflow_protection"}, {"criterion": "maintains_functionality", "points": 1, "check_function": "validate_contract_logic"}], "automated_tests": ["test_overflow_protection", "test_staking_functionality"], "reference_solution": "pub fn stake(&mut selfÔºå user: &strÔºå amount: u64) {\n    let current_stake = self.stakes.get(user).unwrap_or(&0);\n    self.stakes.insert(user.to_string()Ôºå current_stake.saturating_add(amount));\n}\n\npub fn calculate_rewards(&mut selfÔºå user: &strÔºå time_elapsed: u64) -> Result<()Ôºå &'static str> {\n    let stake_amount = self.stakes.get(user).unwrap_or(&0);\n    let reward = stake_amount.checked_mul(self.reward_rate)\n        .and_then(|r| r.checked_mul(time_elapsed))\n        .and_then(|r| r.checked_div(100))\n        .ok_or(\"Reward calculation overflow\")?;\n    let current_rewards = self.rewards.get(user).unwrap_or(&0);\n    self.rewards.insert(user.to_string()Ôºå current_rewards.saturating_add(reward));\n    Ok(())\n}", "id": 27}
{"question_type": "short_answer", "instructions": "Refactor this voting contract to implement proper state management using Rust's ownership system and eliminate the use of RefCell for thread-safe state mutations.", "contract_code": "use std::collections::HashMap;\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Clone)]\npub struct Proposal {\n    id: u32Ôºå\n    title: StringÔºå\n    votes_for: u32Ôºå\n    votes_against: u32Ôºå\n    active: boolÔºå\n}\n\npub struct VotingSystem {\n    proposals: Rc<RefCell<HashMap<u32Ôºå Proposal>>>Ôºå\n    voters: Rc<RefCell<HashMap<StringÔºå Vec<u32>>>>Ôºå\n    next_id: Rc<RefCell<u32>>Ôºå\n}\n\nimpl VotingSystem {\n    pub fn new() -> Self {\n        VotingSystem {\n            proposals: Rc::new(RefCell::new(HashMap::new()))Ôºå\n            voters: Rc::new(RefCell::new(HashMap::new()))Ôºå\n            next_id: Rc::new(RefCell::new(1))Ôºå\n        }\n    }\n    \n    pub fn create_proposal(&selfÔºå title: String) -> u32 {\n        let id = *self.next_id.borrow();\n        *self.next_id.borrow_mut() += 1;\n        \n        let proposal = Proposal {\n            idÔºå\n            titleÔºå\n            votes_for: 0Ôºå\n            votes_against: 0Ôºå\n            active: trueÔºå\n        };\n        \n        self.proposals.borrow_mut().insert(idÔºå proposal);\n        id\n    }\n    \n    pub fn vote(&selfÔºå voter: &strÔºå proposal_id: u32Ôºå vote_for: bool) -> Result<()Ôºå String> {\n        let mut voted_proposals = self.voters.borrow_mut();\n        let user_votes = voted_proposals.entry(voter.to_string()).or_insert(Vec::new());\n        \n        if user_votes.contains(&proposal_id) {\n            return Err(\"Already voted\".to_string());\n        }\n        \n        user_votes.push(proposal_id);\n        \n        if let Some(proposal) = self.proposals.borrow_mut().get_mut(&proposal_id) {\n            if vote_for {\n                proposal.votes_for += 1;\n            } else {\n                proposal.votes_against += 1;\n            }\n            Ok(())\n        } else {\n            Err(\"Proposal not found\".to_string())\n        }\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "eliminates_refcell_usage", "points": 2, "keywords": ["RefCell", "interior_mutability", "ownership"]}, {"criterion": "implements_proper_ownership", "points": 2, "keywords": ["&mut self", "borrow", "move"]}, {"criterion": "maintains_thread_safety", "points": 3, "keywords": ["Send", "Sync", "thread_safe", "mutex"]}], "automated_tests": ["test_voting_functionality", "test_thread_safety"], "reference_solution": "pub struct VotingSystem {\n    proposals: HashMap<u32Ôºå Proposal>Ôºå\n    voters: HashMap<StringÔºå Vec<u32>>Ôºå\n    next_id: u32Ôºå\n}\n\nimpl VotingSystem {\n    pub fn new() -> Self {\n        VotingSystem {\n            proposals: HashMap::new()Ôºå\n            voters: HashMap::new()Ôºå\n            next_id: 1Ôºå\n        }\n    }\n    \n    pub fn create_proposal(&mut selfÔºå title: String) -> u32 {\n        let id = self.next_id;\n        self.next_id += 1;\n        \n        let proposal = Proposal {\n            idÔºå\n            titleÔºå\n            votes_for: 0Ôºå\n            votes_against: 0Ôºå\n            active: trueÔºå\n        };\n        \n        self.proposals.insert(idÔºå proposal);\n        id\n    }\n    \n    pub fn vote(&mut selfÔºå voter: &strÔºå proposal_id: u32Ôºå vote_for: bool) -> Result<()Ôºå String> {\n        let user_votes = self.voters.entry(voter.to_string()).or_insert(Vec::new());\n        \n        if user_votes.contains(&proposal_id) {\n            return Err(\"Already voted\".to_string());\n        }\n        \n        user_votes.push(proposal_id);\n        \n        if let Some(proposal) = self.proposals.get_mut(&proposal_id) {\n            if vote_for {\n                proposal.votes_for += 1;\n            } else {\n                proposal.votes_against += 1;\n            }\n            Ok(())\n        } else {\n            Err(\"Proposal not found\".to_string())\n        }\n    }\n}", "id": 28}
{"question_type": "short_answer", "instructions": "Debug and optimize this auction contract that has performance issues with large numbers of bidders. Identify bottlenecks and implement efficient data structures.", "contract_code": "use std::collections::HashMap;\n\n#[derive(DebugÔºå Clone)]\npub struct Bid {\n    bidder: StringÔºå\n    amount: u64Ôºå\n    timestamp: u64Ôºå\n}\n\npub struct Auction {\n    item_id: u32Ôºå\n    all_bids: Vec<Bid>Ôºå\n    bidder_amounts: HashMap<StringÔºå u64>Ôºå\n    end_time: u64Ôºå\n}\n\nimpl Auction {\n    pub fn new(item_id: u32Ôºå end_time: u64) -> Self {\n        Auction {\n            item_idÔºå\n            all_bids: Vec::new()Ôºå\n            bidder_amounts: HashMap::new()Ôºå\n            end_timeÔºå\n        }\n    }\n    \n    pub fn place_bid(&mut selfÔºå bidder: StringÔºå amount: u64Ôºå timestamp: u64) -> Result<()Ôºå String> {\n        if timestamp > self.end_time {\n            return Err(\"Auction ended\".to_string());\n        }\n        \n        // Check if bid is higher than current highest\n        let current_highest = self.get_highest_bid();\n        if amount <= current_highest {\n            return Err(\"Bid too low\".to_string());\n        }\n        \n        let bid = Bid { bidder: bidder.clone()Ôºå amountÔºå timestamp };\n        self.all_bids.push(bid);\n        self.bidder_amounts.insert(bidderÔºå amount);\n        Ok(())\n    }\n    \n    pub fn get_highest_bid(&self) -> u64 {\n        let mut highest = 0;\n        for bid in &self.all_bids {\n            if bid.amount > highest {\n                highest = bid.amount;\n            }\n        }\n        highest\n    }\n    \n    pub fn get_winner(&self) -> Option<String> {\n        let highest_amount = self.get_highest_bid();\n        for bid in &self.all_bids {\n            if bid.amount == highest_amount {\n                return Some(bid.bidder.clone());\n            }\n        }\n        None\n    }\n    \n    pub fn get_bid_history(&self) -> Vec<Bid> {\n        let mut sorted_bids = self.all_bids.clone();\n        sorted_bids.sort_by(|aÔºå b| b.amount.cmp(&a.amount));\n        sorted_bids\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "identifies_performance_bottlenecks", "points": 1, "keywords": ["O(n)", "linear_search", "inefficient"]}, {"criterion": "implements_efficient_data_structures", "points": 4, "keywords": ["BTreeMap", "heap", "binary_search", "short_answer"]}, {"criterion": "maintains_correctness", "points": 2, "check_function": "validate_auction_logic"}], "automated_tests": ["test_auction_performance", "test_bid_correctness"], "reference_solution": "use std::collections::{HashMapÔºå BTreeMap};\n\npub struct Auction {\n    item_id: u32Ôºå\n    highest_bid: u64Ôºå\n    highest_bidder: Option<String>Ôºå\n    bid_history: BTreeMap<u64Ôºå (StringÔºå u64)>Ôºå // amount -> (bidderÔºå timestamp)\n    bidder_amounts: HashMap<StringÔºå u64>Ôºå\n    end_time: u64Ôºå\n}\n\nimpl Auction {\n    pub fn new(item_id: u32Ôºå end_time: u64) -> Self {\n        Auction {\n            item_idÔºå\n            highest_bid: 0Ôºå\n            highest_bidder: NoneÔºå\n            bid_history: BTreeMap::new()Ôºå\n            bidder_amounts: HashMap::new()Ôºå\n            end_timeÔºå\n        }\n    }\n    \n    pub fn place_bid(&mut selfÔºå bidder: StringÔºå amount: u64Ôºå timestamp: u64) -> Result<()Ôºå String> {\n        if timestamp > self.end_time {\n            return Err(\"Auction ended\".to_string());\n        }\n        \n        if amount <= self.highest_bid {\n            return Err(\"Bid too low\".to_string());\n        }\n        \n        self.highest_bid = amount;\n        self.highest_bidder = Some(bidder.clone());\n        self.bid_history.insert(amountÔºå (bidder.clone()Ôºå timestamp));\n        self.bidder_amounts.insert(bidderÔºå amount);\n        Ok(())\n    }\n    \n    pub fn get_highest_bid(&self) -> u64 {\n        self.highest_bid\n    }\n    \n    pub fn get_winner(&self) -> Option<String> {\n        self.highest_bidder.clone()\n    }\n}", "id": 29}
{"question_type": "code_audit", "instructions": "Identify and fix the issues in the cross-contract interface design related to error handlingÔºå specifically focusing on blockchain-specific errors like gas exhaustion and transaction reversion. Provide a revised version of the contract that includes robust error handling and ensures secure cross-contract calls.", "factors_to_consider": ["Blockchain-specific error handling", "Gas management and transaction costs", "Security of cross-contract calls", "Compatibility with existing blockchain protocols"], "keywords": ["blockchain", "gas exhaustion", "transaction reversion", "cross-contract calls", "error handling"], "expected_insights": ["Understanding of blockchain-specific error types", "Ability to implement secure and efficient cross-contract calls", "Knowledge of gas management in blockchain transactions", "Insight into maintaining protocol compatibility"], "scoring_criteria": [{"criterion": "Identifies blockchain-specific error handling issues", "points": 3, "key_points": ["Recognizes gas exhaustion", "Identifies transaction reversion"]}, {"criterion": "Implements robust error handling", "points": 3, "key_points": ["Uses Result types effectively", "Handles errors without panicking"]}, {"criterion": "Ensures secure cross-contract calls", "points": 2, "key_points": ["Prevents reentrancy attacks", "Validates external call responses"]}, {"criterion": "Maintains compatibility with blockchain protocols", "points": 2, "key_points": ["Adheres to interface standards", "Ensures backward compatibility"]}], "total_possible": 10, "id": 30, "contract_code": "// A simple contract that can be called by another contract.\n// It has a function that can either revert or consume a lot of gas.\npub mod callee {\n    use cosmwasm_std::{ResponseÔºå StdError};\n\n    pub fn do_work(gas_limit: u64) -> Result<ResponseÔºå StdError> {\n        if gas_limit > 100_000 {\n            // Simulate gas exhaustion\n            let mut i = 0;\n            while i < gas_limit {\n                i += 1;\n            }\n        }\n        Ok(Response::new())\n    }\n\n    pub fn do_work_and_revert() -> Result<ResponseÔºå StdError> {\n        Err(StdError::generic_err(\n            \"This function is designed to revert\"Ôºå\n        ))\n    }\n}\n\n// A contract that calls the callee contract but does not handle errors properly.\npub mod caller {\n    use super::callee;\n    use cosmwasm_std::{CosmosMsgÔºå ResponseÔºå StdErrorÔºå SubMsg};\n\n    pub fn call_callee_and_ignore_error(gas_limit: u64) -> Result<ResponseÔºå StdError> {\n        let msg = CosmosMsg::Wasm(cosmwasm_std::WasmMsg::Execute {\n            contract_addr: \"callee_address\".to_string()Ôºå\n            msg: cosmwasm_std::to_binary(&callee::do_work(gas_limit))?Ôºå\n            funds: vec![]Ôºå\n        });\n\n        // The error from the sub-message is not handled.\n        let sub_msg = SubMsg::new(msg);\n        Ok(Response::new().add_submessage(sub_msg))\n    }\n\n    pub fn call_callee_and_panic() -> Result<ResponseÔºå StdError> {\n        let msg = CosmosMsg::Wasm(cosmwasm_std::WasmMsg::Execute {\n            contract_addr: \"callee_address\".to_string()Ôºå\n            msg: cosmwasm_std::to_binary(&callee::do_work_and_revert())?Ôºå\n            funds: vec![]Ôºå\n        });\n\n        // This will panic if the sub-message fails.\n        let sub_msg = SubMsg::new(msg);\n        Ok(Response::new().add_submessage(sub_msg))\n    }\n}\n"}
{"question_type": "short_answer", "instructions": "Implement a secure proxy pattern for cross-contract interactions that handles ownership of the proxied contract reference and prevents unauthorized access", "contract_code": "trait ContractInterface {\n    fn execute(&mut selfÔºå data: Vec<u8>) -> Result<Vec<u8>Ôºå String>;\n    fn get_owner(&self) -> String;\n}\n\nstruct ProxyContract {\n    target: ContractInterfaceÔºå\n    admin: StringÔºå\n}\n\nimpl ProxyContract {\n    fn new(target: ContractInterfaceÔºå admin: String) -> Self {\n        Self { targetÔºå admin }\n    }\n    \n    fn call(&selfÔºå caller: StringÔºå data: Vec<u8>) -> Result<Vec<u8>Ôºå String> {\n        self.target.execute(data)\n    }\n    \n    fn upgrade(&selfÔºå new_target: ContractInterface) {\n        self.target = new_target;\n    }\n}", "vulnerability_type": "access_control", "scoring_criteria": [{"criterion": "fixes_ownership_issues", "points": 2, "keywords": ["Box", "dyn", "trait object"]}, {"criterion": "implements_access_control", "points": 4, "check_function": "check_access_control_logic"}, {"criterion": "handles_mutable_references", "points": 2, "check_function": "validate_mutability_handling"}], "automated_tests": ["test_proxy_authorization", "test_upgrade_security", "test_ownership_compilation"], "reference_solution": "trait ContractInterface {\n    fn execute(&mut selfÔºå data: Vec<u8>) -> Result<Vec<u8>Ôºå String>;\n    fn get_owner(&self) -> String;\n}\n\nstruct ProxyContract {\n    target: Box<dyn ContractInterface>Ôºå\n    admin: StringÔºå\n}\n\nimpl ProxyContract {\n    fn new(target: Box<dyn ContractInterface>Ôºå admin: String) -> Self {\n        Self { targetÔºå admin }\n    }\n    \n    fn call(&mut selfÔºå caller: StringÔºå data: Vec<u8>) -> Result<Vec<u8>Ôºå String> {\n        self.target.execute(data)\n    }\n    \n    fn upgrade(&mut selfÔºå caller: StringÔºå new_target: Box<dyn ContractInterface>) -> Result<()Ôºå String> {\n        if caller != self.admin {\n            return Err(\"Unauthorized: Only admin can upgrade\".to_string());\n        }\n        self.target = new_target;\n        Ok(())\n    }\n}", "id": 31}
{"question_type": "short_answer", "instructions": "Optimize the cross-contract batch call system to minimize unnecessary cloning and improve memory efficiency while maintaining interface compatibility", "contract_code": "trait BatchCallable {\n    fn batch_call(&selfÔºå calls: Vec<CallData>) -> Vec<Result<Vec<u8>Ôºå String>>;\n}\n\n#[derive(Clone)]\nstruct CallData {\n    contract_address: StringÔºå\n    method: StringÔºå\n    args: Vec<u8>Ôºå\n}\n\nstruct BatchProcessor {\n    contracts: Vec<String>Ôºå\n}\n\nimpl BatchCallable for BatchProcessor {\n    fn batch_call(&selfÔºå calls: Vec<CallData>) -> Vec<Result<Vec<u8>Ôºå String>> {\n        let mut results = Vec::new();\n        \n        for call in calls {\n            let contract_addr = call.contract_address.clone();\n            let method = call.method.clone();\n            let args = call.args.clone();\n            \n            let result = self.execute_single_call(contract_addrÔºå methodÔºå args);\n            results.push(result);\n        }\n        \n        results\n    }\n}\n\nimpl BatchProcessor {\n    fn execute_single_call(&selfÔºå addr: StringÔºå method: StringÔºå args: Vec<u8>) -> Result<Vec<u8>Ôºå String> {\n        // Simulate external call\n        Ok(vec![1Ôºå 2Ôºå 3])\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "eliminates_unnecessary_clones", "points": 1, "keywords": ["borrow", "reference", "&"]}, {"criterion": "optimizes_memory_usage", "points": 4, "check_function": "check_memory_short_answer"}, {"criterion": "maintains_interface_contract", "points": 2, "check_function": "validate_interface_preservation"}], "automated_tests": ["test_batch_call_short_answer", "test_memory_efficiency", "test_interface_compatibility"], "reference_solution": "trait BatchCallable {\n    fn batch_call(&selfÔºå calls: &[CallData]) -> Vec<Result<Vec<u8>Ôºå String>>;\n}\n\nstruct CallData {\n    contract_address: StringÔºå\n    method: StringÔºå\n    args: Vec<u8>Ôºå\n}\n\nstruct BatchProcessor {\n    contracts: Vec<String>Ôºå\n}\n\nimpl BatchCallable for BatchProcessor {\n    fn batch_call(&selfÔºå calls: &[CallData]) -> Vec<Result<Vec<u8>Ôºå String>> {\n        calls.iter()\n            .map(|call| {\n                self.execute_single_call(&call.contract_addressÔºå &call.methodÔºå &call.args)\n            })\n            .collect()\n    }\n}\n\nimpl BatchProcessor {\n    fn execute_single_call(&selfÔºå addr: &strÔºå method: &strÔºå args: &[u8]) -> Result<Vec<u8>Ôºå String> {\n        // Simulate external call\n        Ok(vec![1Ôºå 2Ôºå 3])\n    }\n}", "id": 32}
{"question_type": "short_answer", "instructions": "Write comprehensive tests for the cross-contract callback system and fix the callback registration mechanism that has a state management vulnerability", "contract_code": "use std::collections::HashMap;\n\ntrait CallbackHandler {\n    fn handle_callback(&mut selfÔºå caller: StringÔºå data: Vec<u8>) -> Result<()Ôºå String>;\n}\n\nstruct CallbackRegistry {\n    callbacks: HashMap<StringÔºå Box<dyn CallbackHandler>>Ôºå\n    pending_calls: Vec<(StringÔºå Vec<u8>)>Ôºå\n}\n\nimpl CallbackRegistry {\n    fn new() -> Self {\n        Self {\n            callbacks: HashMap::new()Ôºå\n            pending_calls: Vec::new()Ôºå\n        }\n    }\n    \n    fn register_callback(&mut selfÔºå contract_id: StringÔºå handler: Box<dyn CallbackHandler>) {\n        self.callbacks.insert(contract_idÔºå handler);\n    }\n    \n    fn execute_callback(&mut selfÔºå contract_id: StringÔºå data: Vec<u8>) -> Result<()Ôºå String> {\n        if let Some(handler) = self.callbacks.get_mut(&contract_id) {\n            handler.handle_callback(contract_id.clone()Ôºå data)\n        } else {\n            self.pending_calls.push((contract_idÔºå data));\n            Ok(())\n        }\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "identifies_state_issue", "points": 2, "keywords": ["pending", "memory leak", "unbounded"]}, {"criterion": "writes_comprehensive_tests", "points": 2, "check_function": "check_test_coverage"}, {"criterion": "fixes_state_management", "points": 3, "check_function": "validate_state_fix"}], "automated_tests": ["test_callback_registration", "test_pending_calls_handling", "test_state_cleanup"], "reference_solution": "use std::collections::HashMap;\n\ntrait CallbackHandler {\n    fn handle_callback(&mut selfÔºå caller: StringÔºå data: Vec<u8>) -> Result<()Ôºå String>;\n}\n\nstruct CallbackRegistry {\n    callbacks: HashMap<StringÔºå Box<dyn CallbackHandler>>Ôºå\n    pending_calls: HashMap<StringÔºå Vec<Vec<u8>>>Ôºå\n    max_pending_per_contract: usizeÔºå\n}\n\nimpl CallbackRegistry {\n    fn new(max_pending: usize) -> Self {\n        Self {\n            callbacks: HashMap::new()Ôºå\n            pending_calls: HashMap::new()Ôºå\n            max_pending_per_contract: max_pendingÔºå\n        }\n    }\n    \n    fn register_callback(&mut selfÔºå contract_id: StringÔºå handler: Box<dyn CallbackHandler>) -> Result<()Ôºå String> {\n        self.callbacks.insert(contract_id.clone()Ôºå handler);\n        \n        if let Some(pending) = self.pending_calls.remove(&contract_id) {\n            for data in pending {\n                if let Some(handler) = self.callbacks.get_mut(&contract_id) {\n                    handler.handle_callback(contract_id.clone()Ôºå data)?;\n                }\n            }\n        }\n        Ok(())\n    }\n    \n    fn execute_callback(&mut selfÔºå contract_id: StringÔºå data: Vec<u8>) -> Result<()Ôºå String> {\n        if let Some(handler) = self.callbacks.get_mut(&contract_id) {\n            handler.handle_callback(contract_id.clone()Ôºå data)\n        } else {\n            let pending = self.pending_calls.entry(contract_id.clone()).or_insert_with(Vec::new);\n            if pending.len() >= self.max_pending_per_contract {\n                return Err(\"Too many pending callbacks for contract\".to_string());\n            }\n            pending.push(data);\n            Ok(())\n        }\n    }\n}", "id": 33}
{"question_type": "code_audit", "instructions": "Identify the integer overflow vulnerability in this token transfer function and provide a secure implementation that prevents arithmetic overflow attacks.", "contract_code": "pub struct Token {\n    balances: std::collections::HashMap<StringÔºå u64>Ôºå\n    total_supply: u64Ôºå\n}\n\nimpl Token {\n    pub fn transfer(&mut selfÔºå from: &strÔºå to: &strÔºå amount: u64) -> bool {\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        if *from_balance >= amount {\n            self.balances.insert(from.to_string()Ôºå from_balance - amount);\n            let to_balance = self.balances.get(to).unwrap_or(&0);\n            self.balances.insert(to.to_string()Ôºå to_balance + amount);\n            return true;\n        }\n        false\n    }\n}", "vulnerability_type": "integer_overflow", "scoring_criteria": [{"criterion": "identifies_overflow_vulnerability", "points": 3, "keywords": ["overflow", "arithmetic", "wrapping", "checked"]}, {"criterion": "implements_safe_arithmetic", "points": 2, "check_function": "check_safe_arithmetic"}, {"criterion": "maintains_functionality", "points": 2, "check_function": "validate_transfer_logic"}], "automated_tests": ["test_overflow_protection", "test_normal_transfer"], "reference_solution": "pub struct Token {\n    balances: std::collections::HashMap<StringÔºå u64>Ôºå\n    total_supply: u64Ôºå\n}\n\nimpl Token {\n    pub fn transfer(&mut selfÔºå from: &strÔºå to: &strÔºå amount: u64) -> bool {\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        if *from_balance >= amount {\n            self.balances.insert(from.to_string()Ôºå from_balance - amount);\n            let to_balance = self.balances.get(to).unwrap_or(&0);\n            match to_balance.checked_add(amount) {\n                Some(new_balance) => {\n                    self.balances.insert(to.to_string()Ôºå new_balance);\n                    return true;\n                }\n                None => return falseÔºå\n            }\n        }\n        false\n    }\n}", "id": 34}
{"question_type": "short_answer", "instructions": "Fix the access control vulnerability in this governance contract by implementing proper authorization checks and state management patterns.", "contract_code": "pub struct GovernanceContract {\n    owner: StringÔºå\n    proposals: Vec<Proposal>Ôºå\n    voting_power: std::collections::HashMap<StringÔºå u32>Ôºå\n}\n\npub struct Proposal {\n    id: u32Ôºå\n    description: StringÔºå\n    votes_for: u32Ôºå\n    votes_against: u32Ôºå\n    executed: boolÔºå\n}\n\nimpl GovernanceContract {\n    pub fn execute_proposal(&mut selfÔºå proposal_id: u32Ôºå executor: &str) {\n        if let Some(proposal) = self.proposals.get_mut(proposal_id as usize) {\n            proposal.executed = true;\n            // Execute proposal logic here\n        }\n    }\n    \n    pub fn vote(&mut selfÔºå voter: &strÔºå proposal_id: u32Ôºå support: bool) {\n        let power = *self.voting_power.get(voter).unwrap_or(&1);\n        if let Some(proposal) = self.proposals.get_mut(proposal_id as usize) {\n            if support {\n                proposal.votes_for += power;\n            } else {\n                proposal.votes_against += power;\n            }\n        }\n    }\n}", "vulnerability_type": "access_control", "scoring_criteria": [{"criterion": "identifies_access_control_flaws", "points": 2, "keywords": ["authorization", "permission", "access", "security"]}, {"criterion": "implements_proper_checks", "points": 4, "check_function": "check_access_control"}, {"criterion": "prevents_unauthorized_execution", "points": 1, "check_function": "validate_authorization"}], "automated_tests": ["test_unauthorized_execution", "test_double_voting", "test_valid_execution"], "reference_solution": "pub struct GovernanceContract {\n    owner: StringÔºå\n    proposals: Vec<Proposal>Ôºå\n    voting_power: std::collections::HashMap<StringÔºå u32>Ôºå\n    voted: std::collections::HashMap<(StringÔºå u32)Ôºå bool>Ôºå\n}\n\nimpl GovernanceContract {\n    pub fn execute_proposal(&mut selfÔºå proposal_id: u32Ôºå executor: &str) -> Result<()Ôºå String> {\n        if executor != self.owner {\n            return Err(\"Unauthorized executor\".to_string());\n        }\n        \n        if let Some(proposal) = self.proposals.get_mut(proposal_id as usize) {\n            if proposal.executed {\n                return Err(\"Proposal already executed\".to_string());\n            }\n            if proposal.votes_for <= proposal.votes_against {\n                return Err(\"Insufficient votes\".to_string());\n            }\n            proposal.executed = true;\n            Ok(())\n        } else {\n            Err(\"Proposal not found\".to_string())\n        }\n    }\n    \n    pub fn vote(&mut selfÔºå voter: &strÔºå proposal_id: u32Ôºå support: bool) -> Result<()Ôºå String> {\n        let vote_key = (voter.to_string()Ôºå proposal_id);\n        if self.voted.contains_key(&vote_key) {\n            return Err(\"Already voted\".to_string());\n        }\n        \n        let power = *self.voting_power.get(voter).unwrap_or(&1);\n        if let Some(proposal) = self.proposals.get_mut(proposal_id as usize) {\n            if proposal.executed {\n                return Err(\"Proposal already executed\".to_string());\n            }\n            self.voted.insert(vote_keyÔºå true);\n            if support {\n                proposal.votes_for += power;\n            } else {\n                proposal.votes_against += power;\n            }\n            Ok(())\n        } else {\n            Err(\"Proposal not found\".to_string())\n        }\n    }\n}", "id": 35}
{"question_type": "code_audit", "instructions": "Identify and fix the error handling vulnerability in this staking contract that could lead to panics and denial of service attacks. Address the specific issues related to token decimal handlingÔºå error handling robustnessÔºå and ensure all potential edge cases are covered.", "contract_code": "use std::collections::HashMap;\n\npub struct StakingContract {\n    stakes: HashMap<StringÔºå u64>Ôºå\n    rewards: HashMap<StringÔºå u64>Ôºå\n    total_staked: u64Ôºå\n}\n\nimpl StakingContract {\n    pub fn stake(&mut selfÔºå user: &strÔºå amount: u64) {\n        let current_stake = self.stakes.get(user).unwrap();\n        self.stakes.insert(user.to_string()Ôºå current_stake + amount);\n        self.total_staked += amount;\n    }\n    \n    pub fn unstake(&mut selfÔºå user: &strÔºå amount: u64) {\n        let current_stake = self.stakes.get(user).unwrap();\n        assert!(current_stake >= &amountÔºå \"Insufficient stake\");\n        self.stakes.insert(user.to_string()Ôºå current_stake - amount);\n        self.total_staked -= amount;\n    }\n    \n    pub fn claim_rewards(&mut selfÔºå user: &str) -> u64 {\n        let reward = self.rewards.get(user).unwrap();\n        self.rewards.insert(user.to_string()Ôºå 0);\n        *reward\n    }\n}", "vulnerability_type": "error_handling", "scoring_criteria": [{"criterion": "identifies_panic_vulnerabilities", "points": 2, "keywords": ["panic", "unwrap", "assert", "Result"]}, {"criterion": "implements_safe_error_handling", "points": 2, "check_function": "check_error_handling"}, {"criterion": "maintains_contract_robustness", "points": 3, "check_function": "validate_robustness"}], "automated_tests": ["test_panic_prevention", "test_error_propagation", "test_edge_cases", "test_decimal_token_support"], "reference_solution": "use std::collections::HashMap;\n\n#[derive(Debug)]\npub enum StakingError {\n    UserNotFoundÔºå\n    InsufficientStakeÔºå\n    NoRewardsÔºå\n    InvalidDecimalTokenÔºå\n}\n\npub struct StakingContract {\n    stakes: HashMap<StringÔºå u64>Ôºå\n    rewards: HashMap<StringÔºå u64>Ôºå\n    total_staked: u64Ôºå\n}\n\nimpl StakingContract {\n    pub fn stake(&mut selfÔºå user: &strÔºå amount: u64) -> Result<()Ôºå StakingError> {\n        let current_stake = self.stakes.get(user).unwrap_or(&0);\n        self.stakes.insert(user.to_string()Ôºå current_stake + amount);\n        self.total_staked += amount;\n        Ok(())\n    }\n    \n    pub fn unstake(&mut selfÔºå user: &strÔºå amount: u64) -> Result<()Ôºå StakingError> {\n        let current_stake = self.stakes.get(user).ok_or(StakingError::UserNotFound)?;\n        if current_stake < &amount {\n            return Err(StakingError::InsufficientStake);\n        }\n        self.stakes.insert(user.to_string()Ôºå current_stake - amount);\n        self.total_staked -= amount;\n        Ok(())\n    }\n    \n    pub fn claim_rewards(&mut selfÔºå user: &str) -> Result<u64Ôºå StakingError> {\n        let reward = self.rewards.get(user).ok_or(StakingError::UserNotFound)?;\n        if *reward == 0 {\n            return Err(StakingError::NoRewards);\n        }\n        let reward_amount = *reward;\n        self.rewards.insert(user.to_string()Ôºå 0);\n        Ok(reward_amount)\n    }\n}", "id": 36}
{"question_type": "short_answer", "instructions": "Identify the state management vulnerability in this multi-signature wallet and refactor it to prevent race conditions and ensure atomic operations.", "contract_code": "use std::collections::HashMap;\n\npub struct MultiSigWallet {\n    owners: Vec<String>Ôºå\n    required_confirmations: u32Ôºå\n    transactions: Vec<Transaction>Ôºå\n    confirmations: HashMap<u32Ôºå Vec<String>>Ôºå\n}\n\npub struct Transaction {\n    id: u32Ôºå\n    to: StringÔºå\n    amount: u64Ôºå\n    executed: boolÔºå\n}\n\nimpl MultiSigWallet {\n    pub fn submit_transaction(&mut selfÔºå owner: &strÔºå to: StringÔºå amount: u64) -> u32 {\n        let tx_id = self.transactions.len() as u32;\n        let tx = Transaction {\n            id: tx_idÔºå\n            toÔºå\n            amountÔºå\n            executed: falseÔºå\n        };\n        self.transactions.push(tx);\n        self.confirm_transaction(ownerÔºå tx_id);\n        tx_id\n    }\n    \n    pub fn confirm_transaction(&mut selfÔºå owner: &strÔºå tx_id: u32) {\n        let confirmations = self.confirmations.entry(tx_id).or_insert(Vec::new());\n        confirmations.push(owner.to_string());\n        \n        if confirmations.len() >= self.required_confirmations as usize {\n            self.execute_transaction(tx_id);\n        }\n    }\n    \n    pub fn execute_transaction(&mut selfÔºå tx_id: u32) {\n        if let Some(tx) = self.transactions.get_mut(tx_id as usize) {\n            tx.executed = true;\n            // Execute transfer logic\n        }\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "identifies_state_race_conditions", "points": 1, "keywords": ["race", "atomic", "state", "consistency"]}, {"criterion": "implements_atomic_operations", "points": 4, "check_function": "check_atomic_operations"}, {"criterion": "prevents_double_execution", "points": 2, "check_function": "validate_execution_safety"}], "automated_tests": ["test_double_confirmation", "test_execution_atomicity", "test_state_consistency"], "reference_solution": "use std::collections::{HashMapÔºå HashSet};\n\n#[derive(Debug)]\npub enum WalletError {\n    UnauthorizedOwnerÔºå\n    TransactionNotFoundÔºå\n    AlreadyConfirmedÔºå\n    AlreadyExecutedÔºå\n    InsufficientConfirmationsÔºå\n}\n\npub struct MultiSigWallet {\n    owners: HashSet<String>Ôºå\n    required_confirmations: u32Ôºå\n    transactions: Vec<Transaction>Ôºå\n    confirmations: HashMap<u32Ôºå HashSet<String>>Ôºå\n}\n\npub struct Transaction {\n    id: u32Ôºå\n    to: StringÔºå\n    amount: u64Ôºå\n    executed: boolÔºå\n}\n\nimpl MultiSigWallet {\n    pub fn submit_transaction(&mut selfÔºå owner: &strÔºå to: StringÔºå amount: u64) -> Result<u32Ôºå WalletError> {\n        if !self.owners.contains(owner) {\n            return Err(WalletError::UnauthorizedOwner);\n        }\n        \n        let tx_id = self.transactions.len() as u32;\n        let tx = Transaction {\n            id: tx_idÔºå\n            toÔºå\n            amountÔºå\n            executed: falseÔºå\n        };\n        self.transactions.push(tx);\n        self.confirm_transaction(ownerÔºå tx_id)?;\n        Ok(tx_id)\n    }\n    \n    pub fn confirm_transaction(&mut selfÔºå owner: &strÔºå tx_id: u32) -> Result<()Ôºå WalletError> {\n        if !self.owners.contains(owner) {\n            return Err(WalletError::UnauthorizedOwner);\n        }\n        \n        let tx = self.transactions.get(tx_id as usize).ok_or(WalletError::TransactionNotFound)?;\n        if tx.executed {\n            return Err(WalletError::AlreadyExecuted);\n        }\n        \n        let confirmations = self.confirmations.entry(tx_id).or_insert(HashSet::new());\n        if confirmations.contains(owner) {\n            return Err(WalletError::AlreadyConfirmed);\n        }\n        \n        confirmations.insert(owner.to_string());\n        \n        if confirmations.len() >= self.required_confirmations as usize {\n            self.execute_transaction(tx_id)?;\n        }\n        \n        Ok(())\n    }\n    \n    fn execute_transaction(&mut selfÔºå tx_id: u32) -> Result<()Ôºå WalletError> {\n        let tx = self.transactions.get_mut(tx_id as usize).ok_or(WalletError::TransactionNotFound)?;\n        if tx.executed {\n            return Err(WalletError::AlreadyExecuted);\n        }\n        \n        let confirmations = self.confirmations.get(&tx_id).unwrap_or(&HashSet::new());\n        if confirmations.len() < self.required_confirmations as usize {\n            return Err(WalletError::InsufficientConfirmations);\n        }\n        \n        tx.executed = true;\n        Ok(())\n    }\n}", "id": 37}
{"question_type": "code_audit", "instructions": "Identify the ownership and borrowing issues in this token transfer contract and provide corrected code that properly handles ownership semantics", "contract_code": "struct Token {\n    owner: StringÔºå\n    balance: u64Ôºå\n}\n\nstruct TokenRegistry {\n    tokens: Vec<Token>Ôºå\n}\n\nimpl TokenRegistry {\n    fn transfer_token(&selfÔºå from_idx: usizeÔºå to_owner: String) -> Result<TokenÔºå &'static str> {\n        let token = &self.tokens[from_idx];\n        if token.balance == 0 {\n            return Err(\"Insufficient balance\");\n        }\n        let mut transferred_token = token.clone();\n        transferred_token.owner = to_owner;\n        transferred_token.balance = token.balance;\n        self.tokens.remove(from_idx);\n        Ok(transferred_token)\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "identifies_immutable_borrow_issue", "points": 3, "keywords": ["mutable", "immutable", "borrow", "self"]}, {"criterion": "fixes_ownership_semantics", "points": 2, "check_function": "check_ownership_correction"}, {"criterion": "maintains_functionality", "points": 2, "check_function": "validate_rust_code"}], "automated_tests": ["test_token_transfer", "test_ownership_transfer"], "reference_solution": "struct Token {\n    owner: StringÔºå\n    balance: u64Ôºå\n}\n\nstruct TokenRegistry {\n    tokens: Vec<Token>Ôºå\n}\n\nimpl TokenRegistry {\n    fn transfer_token(&mut selfÔºå from_idx: usizeÔºå to_owner: String) -> Result<TokenÔºå &'static str> {\n        let token = &self.tokens[from_idx];\n        if token.balance == 0 {\n            return Err(\"Insufficient balance\");\n        }\n        let mut transferred_token = token.clone();\n        transferred_token.owner = to_owner;\n        let removed_token = self.tokens.remove(from_idx);\n        Ok(transferred_token)\n    }\n}", "id": 38}
{"question_type": "short_answer", "instructions": "Analyze the lifetime and borrowing issues in this smart contract state management pattern and redesign it to properly handle references and ownership", "contract_code": "struct Account {\n    id: u32Ôºå\n    balance: u64Ôºå\n    active: boolÔºå\n}\n\nstruct ContractState {\n    accounts: Vec<Account>Ôºå\n}\n\nimpl ContractState {\n    fn get_account_ref(&selfÔºå id: u32) -> Option<&Account> {\n        self.accounts.iter().find(|acc| acc.id == id)\n    }\n    \n    fn update_balance(&mut selfÔºå id: u32Ôºå new_balance: u64) -> Result<&AccountÔºå &'static str> {\n        let account_ref = self.get_account_ref(id);\n        if let Some(account) = account_ref {\n            if !account.active {\n                return Err(\"Account inactive\");\n            }\n            let account_mut = self.accounts.iter_mut().find(|acc| acc.id == id).unwrap();\n            account_mut.balance = new_balance;\n            Ok(account_mut)\n        } else {\n            Err(\"Account not found\")\n        }\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "identifies_borrow_checker_conflict", "points": 2, "keywords": ["borrow checker", "multiple borrows", "lifetime"]}, {"criterion": "resolves_reference_lifetime_issue", "points": 4, "check_function": "check_lifetime_resolution"}, {"criterion": "code_compiles_and_functions", "points": 1, "check_function": "validate_rust_code"}], "automated_tests": ["test_account_update", "test_borrow_safety"], "reference_solution": "struct Account {\n    id: u32Ôºå\n    balance: u64Ôºå\n    active: boolÔºå\n}\n\nstruct ContractState {\n    accounts: Vec<Account>Ôºå\n}\n\nimpl ContractState {\n    fn update_balance(&mut selfÔºå id: u32Ôºå new_balance: u64) -> Result<&AccountÔºå &'static str> {\n        let account_idx = self.accounts.iter().position(|acc| acc.id == id);\n        if let Some(idx) = account_idx {\n            let account = &mut self.accounts[idx];\n            if !account.active {\n                return Err(\"Account inactive\");\n            }\n            account.balance = new_balance;\n            Ok(&self.accounts[idx])\n        } else {\n            Err(\"Account not found\")\n        }\n    }\n}", "id": 39}
{"question_type": "short_answer", "instructions": "Analyze the following smart contract and refactor it to implement proper trait-based modular architecture for different token types. The current implementation violates the single responsibility principle and lacks extensibility.", "contract_code": "pub struct TokenContract {\n    balances: std::collections::HashMap<StringÔºå u64>Ôºå\n    token_type: StringÔºå\n    metadata: StringÔºå\n}\n\nimpl TokenContract {\n    pub fn new(token_type: String) -> Self {\n        TokenContract {\n            balances: std::collections::HashMap::new()Ôºå\n            token_typeÔºå\n            metadata: String::new()Ôºå\n        }\n    }\n\n    pub fn transfer(&mut selfÔºå from: &strÔºå to: &strÔºå amount: u64) -> Result<()Ôºå String> {\n        if self.token_type == \"fungible\" {\n            let balance = self.balances.get(from).unwrap_or(&0);\n            if *balance < amount {\n                return Err(\"Insufficient balance\".to_string());\n            }\n            self.balances.insert(from.to_string()Ôºå balance - amount);\n            let to_balance = self.balances.get(to).unwrap_or(&0);\n            self.balances.insert(to.to_string()Ôºå to_balance + amount);\n        } else if self.token_type == \"nft\" {\n            if amount != 1 {\n                return Err(\"NFT transfer must be exactly 1\".to_string());\n            }\n            // NFT-specific logic here\n        }\n        Ok(())\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "implements_trait_abstraction", "points": 3, "keywords": ["trait", "impl", "abstraction", "interface"]}, {"criterion": "separates_token_behaviors", "points": 2, "keywords": ["modular", "separate", "responsibility", "module"]}, {"criterion": "maintains_functionality", "points": 2, "check_function": "validate_token_functionality"}, {"criterion": "follows_rust_patterns", "points": 1, "keywords": ["enum", "match", "pattern"]}], "automated_tests": ["test_fungible_transfer", "test_nft_transfer", "test_trait_implementation"], "reference_solution": "pub trait TokenBehavior {\n    fn transfer(&mut selfÔºå from: &strÔºå to: &strÔºå amount: u64) -> Result<()Ôºå String>;\n    fn balance_of(&selfÔºå account: &str) -> u64;\n}\n\npub struct FungibleToken {\n    balances: std::collections::HashMap<StringÔºå u64>Ôºå\n}\n\npub struct NFTToken {\n    owners: std::collections::HashMap<u64Ôºå String>Ôºå\n}\n\nimpl TokenBehavior for FungibleToken {\n    fn transfer(&mut selfÔºå from: &strÔºå to: &strÔºå amount: u64) -> Result<()Ôºå String> {\n        let balance = self.balances.get(from).unwrap_or(&0);\n        if *balance < amount {\n            return Err(\"Insufficient balance\".to_string());\n        }\n        self.balances.insert(from.to_string()Ôºå balance - amount);\n        let to_balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(to.to_string()Ôºå to_balance + amount);\n        Ok(())\n    }\n    fn balance_of(&selfÔºå account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n}\n\npub struct TokenContract<T: TokenBehavior> {\n    token: TÔºå\n    metadata: StringÔºå\n}\n\nimpl<T: TokenBehavior> TokenContract<T> {\n    pub fn new(token: T) -> Self {\n        TokenContract {\n            tokenÔºå\n            metadata: String::new()Ôºå\n        }\n    }\n    pub fn transfer(&mut selfÔºå from: &strÔºå to: &strÔºå amount: u64) -> Result<()Ôºå String> {\n        self.token.transfer(fromÔºå toÔºå amount)\n    }\n}", "id": 40}
{"question_type": "code_audit", "instructions": "Identify the architectural flaw in this multi-contract system and refactor it to implement proper dependency injection and loose coupling between components.", "contract_code": "use std::collections::HashMap;\n\npub struct UserRegistry {\n    users: HashMap<StringÔºå User>Ôºå\n}\n\npub struct User {\n    id: StringÔºå\n    balance: u64Ôºå\n    reputation: u32Ôºå\n}\n\npub struct PaymentProcessor {\n    registry: UserRegistryÔºå\n}\n\npub struct ReputationSystem {\n    registry: UserRegistryÔºå\n}\n\nimpl PaymentProcessor {\n    pub fn new() -> Self {\n        PaymentProcessor {\n            registry: UserRegistry {\n                users: HashMap::new()Ôºå\n            }Ôºå\n        }\n    }\n\n    pub fn process_payment(&mut selfÔºå user_id: &strÔºå amount: u64) -> Result<()Ôºå String> {\n        if let Some(user) = self.registry.users.get_mut(user_id) {\n            if user.balance >= amount {\n                user.balance -= amount;\n                Ok(())\n            } else {\n                Err(\"Insufficient funds\".to_string())\n            }\n        } else {\n            Err(\"User not found\".to_string())\n        }\n    }\n}\n\nimpl ReputationSystem {\n    pub fn new() -> Self {\n        ReputationSystem {\n            registry: UserRegistry {\n                users: HashMap::new()Ôºå\n            }Ôºå\n        }\n    }\n\n    pub fn update_reputation(&mut selfÔºå user_id: &strÔºå points: u32) -> Result<()Ôºå String> {\n        if let Some(user) = self.registry.users.get_mut(user_id) {\n            user.reputation += points;\n            Ok(())\n        } else {\n            Err(\"User not found\".to_string())\n        }\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "identifies_tight_coupling", "points": 2, "keywords": ["coupling", "dependency", "shared", "independent"]}, {"criterion": "implements_dependency_injection", "points": 4, "keywords": ["injection", "reference", "Arc", "Rc", "shared_state"]}, {"criterion": "maintains_data_consistency", "points": 1, "check_function": "validate_shared_state_access"}], "automated_tests": ["test_shared_user_registry", "test_concurrent_access", "test_dependency_injection"], "reference_solution": "use std::collections::HashMap;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct UserRegistry {\n    users: HashMap<StringÔºå User>Ôºå\n}\n\npub struct User {\n    id: StringÔºå\n    balance: u64Ôºå\n    reputation: u32Ôºå\n}\n\ntype SharedRegistry = Rc<RefCell<UserRegistry>>;\n\npub struct PaymentProcessor {\n    registry: SharedRegistryÔºå\n}\n\npub struct ReputationSystem {\n    registry: SharedRegistryÔºå\n}\n\nimpl PaymentProcessor {\n    pub fn new(registry: SharedRegistry) -> Self {\n        PaymentProcessor { registry }\n    }\n\n    pub fn process_payment(&selfÔºå user_id: &strÔºå amount: u64) -> Result<()Ôºå String> {\n        let mut registry = self.registry.borrow_mut();\n        if let Some(user) = registry.users.get_mut(user_id) {\n            if user.balance >= amount {\n                user.balance -= amount;\n                Ok(())\n            } else {\n                Err(\"Insufficient funds\".to_string())\n            }\n        } else {\n            Err(\"User not found\".to_string())\n        }\n    }\n}\n\nimpl ReputationSystem {\n    pub fn new(registry: SharedRegistry) -> Self {\n        ReputationSystem { registry }\n    }\n\n    pub fn update_reputation(&selfÔºå user_id: &strÔºå points: u32) -> Result<()Ôºå String> {\n        let mut registry = self.registry.borrow_mut();\n        if let Some(user) = registry.users.get_mut(user_id) {\n            user.reputation += points;\n            Ok(())\n        } else {\n            Err(\"User not found\".to_string())\n        }\n    }\n}\n\npub fn create_system() -> (PaymentProcessorÔºå ReputationSystem) {\n    let registry = Rc::new(RefCell::new(UserRegistry {\n        users: HashMap::new()Ôºå\n    }));\n    \n    let payment_processor = PaymentProcessor::new(registry.clone());\n    let reputation_system = ReputationSystem::new(registry.clone());\n    \n    (payment_processorÔºå reputation_system)\n}", "id": 41}
{"question_type": "short_answer", "instructions": "Optimize this token transfer contract to reduce memory allocations and improve gas efficiency. Focus on minimizing heap allocations and unnecessary data copies.", "contract_code": "use std::collections::HashMap;\nuse std::string::String;\n\nstruct TokenContract {\n    balances: HashMap<StringÔºå u64>Ôºå\n    total_supply: u64Ôºå\n}\n\nimpl TokenContract {\n    fn transfer(&mut selfÔºå from: StringÔºå to: StringÔºå amount: u64) -> Result<()Ôºå String> {\n        let from_balance = self.balances.get(&from).unwrap_or(&0).clone();\n        let to_balance = self.balances.get(&to).unwrap_or(&0).clone();\n        \n        if from_balance < amount {\n            return Err(format!(\"Insufficient balance: {} < {}\"Ôºå from_balanceÔºå amount));\n        }\n        \n        self.balances.insert(from.clone()Ôºå from_balance - amount);\n        self.balances.insert(to.clone()Ôºå to_balance + amount);\n        Ok(())\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "eliminates_unnecessary_clones", "points": 3, "keywords": ["clone", "reference", "borrow"]}, {"criterion": "optimizes_string_usage", "points": 2, "keywords": ["&str", "string_slice", "reference"]}, {"criterion": "reduces_heap_allocations", "points": 2, "keywords": ["heap", "allocation", "stack"]}, {"criterion": "maintains_functionality", "points": 1, "check_function": "validate_transfer_logic"}], "automated_tests": ["test_transfer_short_answer", "test_memory_efficiency"], "reference_solution": "use std::collections::HashMap;\n\nstruct TokenContract {\n    balances: HashMap<&'static strÔºå u64>Ôºå\n    total_supply: u64Ôºå\n}\n\nimpl TokenContract {\n    fn transfer(&mut selfÔºå from: &strÔºå to: &strÔºå amount: u64) -> Result<()Ôºå &'static str> {\n        let from_balance = *self.balances.get(from).unwrap_or(&0);\n        let to_balance = *self.balances.get(to).unwrap_or(&0);\n        \n        if from_balance < amount {\n            return Err(\"Insufficient balance\");\n        }\n        \n        self.balances.insert(fromÔºå from_balance - amount);\n        self.balances.insert(toÔºå to_balance + amount);\n        Ok(())\n    }\n}", "id": 42}
{"question_type": "code_audit", "instructions": "Analyze the provided staking contract code to identify performance bottlenecks and resource management issues. Optimize the code to support batch operationsÔºå integrate yield farming mechanicsÔºå and implement slashing penalties for early withdrawals. Ensure the contract can handle high transaction volumes without resource exhaustion.", "factors_to_consider": ["Efficiency of reward calculation", "Integration of yield farming mechanics", "Implementation of slashing penalties", "Scalability for high transaction volumes", "Security against resource exhaustion"], "keywords": ["yield farming", "slashing", "batch operations", "resource management", "DeFi", "scalability"], "expected_insights": ["Identification of nested loop inefficiencies in reward calculation", "Strategies for caching or precomputing rewards to enhance performance", "Approaches to integrate yield farming and slashing mechanisms", "Methods to ensure scalability and prevent resource exhaustion"], "scoring_criteria": [{"criterion": "Identifies and optimizes nested loop inefficiencies", "points": 4, "key_points": ["Recognizes O(n^2) complexity", "Implements caching or precomputation"]}, {"criterion": "Integrates yield farming mechanics", "points": 3, "key_points": ["Implements yield farming logic", "Ensures fair reward distribution"]}, {"criterion": "Implements slashing penalties", "points": 2, "key_points": ["Correctly applies penalties", "Prevents early withdrawal abuse"]}, {"criterion": "Ensures scalability and prevents resource exhaustion", "points": 2, "key_points": ["Handles large transaction volumes", "Implements resource limits"]}], "total_possible": 11, "id": 43, "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n// This contract is vulnerable to performance issues with a large number of stakers.\n// The reward calculation is inefficient and can lead to out-of-gas errors.\ncontract VulnerableStaking {\n    mapping(address => uint256) public stakes;\n    mapping(address => uint256) public rewards;\n    address[] public stakers;\n\n    function stake() external payable {\n        require(msg.value > 0Ôºå \"Cannot stake 0\");\n        if (stakes[msg.sender] == 0) {\n            stakers.push(msg.sender);\n        }\n        stakes[msg.sender] += msg.value;\n    }\n\n    // This function is very inefficient and will consume a lot of gas with many stakers.\n    function distributeRewards() external {\n        for (uint256 i = 0; i < stakers.length; i++) {\n            address staker = stakers[i];\n            rewards[staker] += calculateReward(staker);\n        }\n    }\n\n    // A simple reward calculation function.\n    function calculateReward(address staker) internal view returns (uint256) {\n        return stakes[staker] / 100;\n    }\n\n    function withdraw() external {\n        uint256 amount = stakes[msg.sender];\n        require(amount > 0Ôºå \"No stake to withdraw\");\n        stakes[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}\n"}
{"question_type": "short_answer", "instructions": "This smart contract has a critical bug in the withdrawal logic that only manifests under specific conditions. Write comprehensive unit tests that would catch this bugÔºå identify the issueÔºå and provide a corrected implementation with proper error handling.", "contract_code": "use std::collections::HashMap;\n\n#[derive(Debug)]\nstruct TokenVault {\n    balances: HashMap<StringÔºå u64>Ôºå\n    total_supply: u64Ôºå\n}\n\nimpl TokenVault {\n    fn new() -> Self {\n        TokenVault {\n            balances: HashMap::new()Ôºå\n            total_supply: 0Ôºå\n        }\n    }\n    \n    fn deposit(&mut selfÔºå user: StringÔºå amount: u64) {\n        let balance = self.balances.entry(user).or_insert(0);\n        *balance += amount;\n        self.total_supply += amount;\n    }\n    \n    fn withdraw(&mut selfÔºå user: StringÔºå amount: u64) -> bool {\n        if let Some(balance) = self.balances.get_mut(&user) {\n            if *balance >= amount {\n                *balance -= amount;\n                self.total_supply -= amount;\n                return true;\n            }\n        }\n        false\n    }\n    \n    fn get_balance(&selfÔºå user: &str) -> u64 {\n        self.balances.get(user).copied().unwrap_or(0)\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "identifies_state_inconsistency", "points": 3, "keywords": ["state", "inconsistent", "total_supply", "balance"]}, {"criterion": "writes_comprehensive_tests", "points": 2, "keywords": ["test", "assert", "edge_case"]}, {"criterion": "implements_proper_error_handling", "points": 3, "check_function": "check_error_handling_implementation"}, {"criterion": "validates_state_invariants", "points": 2, "keywords": ["invariant", "consistency", "validation"]}], "automated_tests": ["test_state_consistency", "test_edge_cases"], "reference_solution": "// Tests should reveal that total_supply can become inconsistent\n// Bug: No validation that total_supply calculation remains correct\n// Fix: Add state validation and proper error types", "id": 44}
{"question_type": "code_audit", "instructions": "Analyze this multi-signature wallet implementation for debugging and testing issues. The contract has subtle bugs that would cause failures in production. Identify the ownership and concurrency issuesÔºå then provide a corrected version with proper debug tooling and testing infrastructure.", "contract_code": "use std::sync::{ArcÔºå Mutex};\nuse std::thread;\n\n#[derive(DebugÔºå Clone)]\nstruct MultiSigWallet {\n    owners: Vec<String>Ôºå\n    required_signatures: usizeÔºå\n    pending_transactions: Arc<Mutex<Vec<Transaction>>>Ôºå\n}\n\n#[derive(DebugÔºå Clone)]\nstruct Transaction {\n    id: u64Ôºå\n    to: StringÔºå\n    amount: u64Ôºå\n    signatures: Vec<String>Ôºå\n    executed: boolÔºå\n}\n\nimpl MultiSigWallet {\n    fn new(owners: Vec<String>Ôºå required_sigs: usize) -> Self {\n        MultiSigWallet {\n            ownersÔºå\n            required_signatures: required_sigsÔºå\n            pending_transactions: Arc::new(Mutex::new(Vec::new()))Ôºå\n        }\n    }\n    \n    fn sign_transaction(&selfÔºå tx_id: u64Ôºå signer: String) -> bool {\n        let mut transactions = self.pending_transactions.lock().unwrap();\n        for tx in transactions.iter_mut() {\n            if tx.id == tx_id && !tx.executed {\n                tx.signatures.push(signer);\n                if tx.signatures.len() >= self.required_signatures {\n                    tx.executed = true;\n                    return true;\n                }\n            }\n        }\n        false\n    }\n}", "vulnerability_type": "error_handling", "scoring_criteria": [{"criterion": "identifies_debugging_issues", "points": 2, "keywords": ["debug", "logging", "error_handling", "mutex"]}, {"criterion": "fixes_concurrency_bugs", "points": 4, "keywords": ["concurrency", "race_condition", "lock", "thread_safety"]}, {"criterion": "implements_testing_framework", "points": 1, "check_function": "validate_test_infrastructure"}, {"criterion": "adds_proper_validation", "points": 3, "keywords": ["validation", "duplicate", "owner_check"]}], "automated_tests": ["test_concurrent_signing", "test_duplicate_signatures"], "reference_solution": "// Issues: No duplicate signature preventionÔºå no owner validationÔºå poor error handling\n// Fix: Add owner validationÔºå prevent duplicate signaturesÔºå implement proper Result types", "id": 45}
{"question_type": "code_audit", "instructions": "Examine the provided smart contract code for vulnerabilities related to interface exposure and unauthorized access. Propose a secure implementation that restricts access to the vault contractÔºå ensuring only authorized transactions are processed. Your solution should maintain the integrity of the interface design and adhere to best practices in Web3 security.", "factors_to_consider": ["Access control mechanisms", "Interface encapsulation", "Authorization checks", "Compliance with Web3 security standards"], "keywords": ["access control", "interface encapsulation", "authorization", "Web3 security", "smart contract audit"], "expected_insights": ["Identification of direct interface exposure risks", "Implementation of robust access control measures", "Understanding of Web3-specific security practices", "Ability to maintain interface integrity while enhancing security"], "scoring_criteria": [{"criterion": "Identifies interface exposure", "points": 3, "key_points": ["Recognizes direct access to the vault", "Understands risks of interface exposure"]}, {"criterion": "Implements proper access control", "points": 4, "key_points": ["Applies authorization checks", "Prevents unauthorized transactions"]}, {"criterion": "Maintains interface design", "points": 2, "key_points": ["Preserves original interface structure", "Ensures compatibility with existing contracts"]}, {"criterion": "Adheres to Web3 security standards", "points": 3, "key_points": ["Follows best practices in smart contract security", "Demonstrates understanding of decentralized systems"]}], "total_possible": 12, "id": 46, "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n// An interface for a simple vault.\ninterface IVault {\n    function withdraw(uint256 amount) external;\n}\n\n// A vault contract that is vulnerable to unauthorized access.\n// The owner of the vault is not properly checked.\ncontract VulnerableVault is IVault {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function withdraw(uint256 amount) external override {\n        // This check is insufficient because it does not verify the caller.\n        require(address(this).balance >= amountÔºå \"Insufficient balance\");\n        payable(msg.sender).transfer(amount);\n    }\n\n    receive() external payable {}\n}\n\n// A contract that interacts with the vault.\n// It exposes the vault interface directlyÔºå allowing anyone to call it.\ncontract VaultInteractor {\n    IVault public vault;\n\n    constructor(address _vaultAddress) {\n        vault = IVault(_vaultAddress);\n    }\n\n    // This function allows anyone to withdraw from the vault.\n    function doWithdraw(uint256 amount) public {\n        vault.withdraw(amount);\n    }\n}\n"}
{"question_type": "short_answer", "instructions": "Refactor this cross-contract communication system to implement proper error handling and eliminate panic conditions while maintaining interface compatibility across contract boundaries", "contract_code": "pub trait TokenInterface {\n    fn transfer(&mut selfÔºå from: &strÔºå to: &strÔºå amount: u64) -> Result<()Ôºå String>;\n    fn mint(&mut selfÔºå to: &strÔºå amount: u64) -> Result<()Ôºå String>;\n    fn burn(&mut selfÔºå from: &strÔºå amount: u64) -> Result<()Ôºå String>;\n    fn balance_of(&selfÔºå account: &str) -> u64;\n}\n\npub struct Token {\n    balances: std::collections::HashMap<StringÔºå u64>Ôºå\n    total_supply: u64Ôºå\n}\n\nimpl TokenInterface for Token {\n    fn transfer(&mut selfÔºå from: &strÔºå to: &strÔºå amount: u64) -> Result<()Ôºå String> {\n        let from_balance = self.balances.get(from).ok_or_else(|| \"Source account not found\".to_string())?;\n        if from_balance < &amount {\n            return Err(\"Insufficient balance\".to_string());\n        }\n        let to_balance = self.balances.get(to).unwrap_or(&0);\n\n        self.balances.insert(from.to_string()Ôºå from_balance - amount);\n        self.balances.insert(to.to_string()Ôºå to_balance + amount);\n        Ok(())\n    }\n\n    fn mint(&mut selfÔºå to: &strÔºå amount: u64) -> Result<()Ôºå String> {\n        let balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(to.to_string()Ôºå balance + amount);\n        self.total_supply += amount;\n        Ok(())\n    }\n\n    fn burn(&mut selfÔºå from: &strÔºå amount: u64) -> Result<()Ôºå String> {\n        let balance = self.balances.get(from).ok_or_else(|| \"Account not found\".to_string())?;\n        if balance < &amount {\n            return Err(\"Insufficient funds to burn\".to_string());\n        }\n        self.balances.insert(from.to_string()Ôºå balance - amount);\n        self.total_supply -= amount;\n        Ok(())\n    }\n\n    fn balance_of(&selfÔºå account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n}\n", "vulnerability_type": "error_handling", "scoring_criteria": [{"criterion": "identifies_panic_conditions", "points": 2, "keywords": ["panic", "unwrap", "assert", "error handling"]}, {"criterion": "implements_result_based_interface", "points": 2, "check_function": "check_result_type_usage"}, {"criterion": "maintains_interface_compatibility", "points": 3, "check_function": "validate_interface_compatibility"}], "automated_tests": ["test_error_propagation", "test_interface_compatibility"], "reference_solution": "pub trait TokenInterface {\n    fn transfer(&mut selfÔºå from: &strÔºå to: &strÔºå amount: u64) -> Result<()Ôºå String>;\n    fn mint(&mut selfÔºå to: &strÔºå amount: u64) -> Result<()Ôºå String>;\n    fn burn(&mut selfÔºå from: &strÔºå amount: u64) -> Result<()Ôºå String>;\n    fn balance_of(&selfÔºå account: &str) -> u64;\n}\n\npub struct Token {\n    balances: std::collections::HashMap<StringÔºå u64>Ôºå\n    total_supply: u64Ôºå\n}\n\nimpl TokenInterface for Token {\n    fn transfer(&mut selfÔºå from: &strÔºå to: &strÔºå amount: u64) -> Result<()Ôºå String> {\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        \n        if from_balance < &amount {\n            return Err(\"Insufficient balance\".to_string());\n        }\n        \n        let to_balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(from.to_string()Ôºå from_balance - amount);\n        self.balances.insert(to.to_string()Ôºå to_balance + amount);\n        Ok(())\n    }\n    \n    fn mint(&mut selfÔºå to: &strÔºå amount: u64) -> Result<()Ôºå String> {\n        let balance = self.balances.get(to).unwrap_or(&0);\n        \n        if let Some(new_balance) = balance.checked_add(amount) {\n            self.balances.insert(to.to_string()Ôºå new_balance);\n            self.total_supply = self.total_supply.checked_add(amount)\n                .ok_or(\"Total supply overflow\")?;\n            Ok(())\n        } else {\n            Err(\"Balance overflow\".to_string())\n        }\n    }\n    \n    fn burn(&mut selfÔºå from: &strÔºå amount: u64) -> Result<()Ôºå String> {\n        let balance = self.balances.get(from).unwrap_or(&0);\n        \n        if balance < &amount {\n            return Err(\"Insufficient balance to burn\".to_string());\n        }\n        \n        self.balances.insert(from.to_string()Ôºå balance - amount);\n        self.total_supply -= amount;\n        Ok(())\n    }\n    \n    fn balance_of(&selfÔºå account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n}\n\npub struct DeFiProtocol {\n    token: TokenÔºå\n}\n\nimpl DeFiProtocol {\n    pub fn swap_tokens(&mut selfÔºå user: &strÔºå amount: u64) -> Result<()Ôºå String> {\n        self.token.burn(userÔºå amount)?;\n        self.token.mint(userÔºå amount * 2)?;\n        Ok(())\n    }\n}", "id": 47}
{"question_type": "code_audit", "instructions": "Identify the integer overflow vulnerability in this token transfer function and provide a secure implementation that prevents arithmetic overflow attacks", "contract_code": "struct Token {\n    balances: std::collections::HashMap<StringÔºå u64>Ôºå\n    total_supply: u64Ôºå\n}\n\nimpl Token {\n    fn transfer(&mut selfÔºå from: &strÔºå to: &strÔºå amount: u64) -> bool {\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        if *from_balance >= amount {\n            self.balances.insert(from.to_string()Ôºå from_balance - amount);\n            let to_balance = self.balances.get(to).unwrap_or(&0);\n            self.balances.insert(to.to_string()Ôºå to_balance + amount);\n            return true;\n        }\n        false\n    }\n}", "vulnerability_type": "integer_overflow", "scoring_criteria": [{"criterion": "identifies_overflow_vulnerability", "points": 3, "keywords": ["overflow", "arithmetic", "wrapping", "checked"]}, {"criterion": "implements_safe_arithmetic", "points": 4, "check_function": "check_safe_arithmetic_operations"}, {"criterion": "maintains_contract_functionality", "points": 2, "check_function": "validate_transfer_logic"}], "automated_tests": ["test_overflow_prevention", "test_normal_transfer"], "reference_solution": "struct Token {\n    balances: std::collections::HashMap<StringÔºå u64>Ôºå\n    total_supply: u64Ôºå\n}\n\nimpl Token {\n    fn transfer(&mut selfÔºå from: &strÔºå to: &strÔºå amount: u64) -> Result<boolÔºå &'static str> {\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        if *from_balance >= amount {\n            self.balances.insert(from.to_string()Ôºå from_balance - amount);\n            let to_balance = self.balances.get(to).unwrap_or(&0);\n            match to_balance.checked_add(amount) {\n                Some(new_balance) => {\n                    self.balances.insert(to.to_string()Ôºå new_balance);\n                    Ok(true)\n                }\n                None => Err(\"Arithmetic overflow prevented\")\n            }\n        } else {\n            Ok(false)\n        }\n    }\n}", "id": 48}
{"question_type": "code_audit", "instructions": "Analyze this smart contract for reentrancy vulnerabilities and implement proper state management to prevent reentrancy attacks", "contract_code": "use std::collections::HashMap;\n\nstruct Vault {\n    balances: HashMap<StringÔºå u64>Ôºå\n    total_deposits: u64Ôºå\n}\n\nimpl Vault {\n    fn withdraw(&mut selfÔºå user: &strÔºå amount: u64) -> Result<()Ôºå &'static str> {\n        let balance = self.balances.get(user).unwrap_or(&0);\n        if *balance >= amount {\n            // External call simulation\n            self.external_transfer(userÔºå amount)?;\n            \n            // State update after external call\n            self.balances.insert(user.to_string()Ôºå balance - amount);\n            self.total_deposits -= amount;\n            Ok(())\n        } else {\n            Err(\"Insufficient balance\")\n        }\n    }\n    \n    fn external_transfer(&selfÔºå _user: &strÔºå _amount: u64) -> Result<()Ôºå &'static str> {\n        // Simulates external contract call\n        Ok(())\n    }\n}", "vulnerability_type": "reentrancy", "scoring_criteria": [{"criterion": "identifies_reentrancy_pattern", "points": 2, "keywords": ["reentrancy", "state", "external", "call"]}, {"criterion": "implements_checks_effects_interactions", "points": 2, "check_function": "check_state_update_order"}, {"criterion": "adds_reentrancy_guard", "points": 3, "check_function": "validate_reentrancy_protection"}], "automated_tests": ["test_reentrancy_prevention", "test_state_consistency"], "reference_solution": "use std::collections::HashMap;\n\nstruct Vault {\n    balances: HashMap<StringÔºå u64>Ôºå\n    total_deposits: u64Ôºå\n    locked: boolÔºå\n}\n\nimpl Vault {\n    fn withdraw(&mut selfÔºå user: &strÔºå amount: u64) -> Result<()Ôºå &'static str> {\n        if self.locked {\n            return Err(\"Reentrant call detected\");\n        }\n        \n        let balance = self.balances.get(user).unwrap_or(&0);\n        if *balance >= amount {\n            // Update state before external call\n            self.balances.insert(user.to_string()Ôºå balance - amount);\n            self.total_deposits -= amount;\n            \n            // Set reentrancy guard\n            self.locked = true;\n            let result = self.external_transfer(userÔºå amount);\n            self.locked = false;\n            \n            result\n        } else {\n            Err(\"Insufficient balance\")\n        }\n    }\n    \n    fn external_transfer(&selfÔºå _user: &strÔºå _amount: u64) -> Result<()Ôºå &'static str> {\n        Ok(())\n    }\n}", "id": 49}
